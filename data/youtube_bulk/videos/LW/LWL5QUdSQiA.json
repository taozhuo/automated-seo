{"id": "LWL5QUdSQiA", "title": "All Of Roblox Lua (Luau) in 21 Minutes", "channel": "KatanaBladeHD", "views": 70880, "duration": "20:48", "url": "https://www.youtube.com/watch?v=LWL5QUdSQiA", "query": "roblox lua tutorial beginner", "transcript": "This is Lua, a highle programming language that was founded in Brazil back in the 1990s. It's designed to be fast, simple, and easy to embed into other programs, which is why it's often used in games, apps, and software extensions. Lua actually means moon in Portuguese, and its syntax is clean and beginnerfriendly, making it a great first programming language to learn. Now, the version of Lua we'll actually be using is called Lu. This is Roblox's own version of the language. Lu started as Lua 5.1 but has been upgraded with extra features such as better performance, type checking, and more built-in functions which are super useful for game development. So if you've used Lua before, Lu look almost completely identical. So the same concepts should still apply. We'll begin learning this language by declaring variables. We can declare a variable by writing local the name of the variable and then making it equal to whatever value you want to associate with it. This is called a local variable. If you don't use the word local, it would be a global variable. Generally, you never want to use a global variable for reasons I'm going to explain at the very end of this video. Just know if you ever want to declare a variable, always use the syntax local to declare it. There are eight basic data types: number, string, nil, boolean, table, and function. The last two data types are called threads and user data. These two are a bit more complicated, so I'm going to explain them towards the end of this video. Numbers. Numbers can represent whole numbers as well as floats. With number variables, you can perform basic arithmetic such as addition, subtraction, multiplication, and division. We can showcase these numbers in the output log by using a print statement. More advanced functions include for division, modulus, exponentiation, and double negation, which are all native to lure arithmetic. You can also write comments like this with a double dash sign, which have a unique gray syntax color on default, which is why this doesn't print anything as it's ignored by the compiler. It's useful for keeping notes and seeing organized strings. Strings represent a set of characters which you can declare by putting them in quotation marks. Anything on quotation marks are considered strings including numbers and special characters. You can combine strings together like this of a double period. This is called concatenation. There's also string slicing which you can do by writing string sub our string variable our start number and the end number. This way you can print out a portion of the string. Nil nil represents the absence of a value. Since no value is assigned to this variable, this value is automatically initialized as nil. You can also manually assign nil like this too. Boolean. Boolean represents true or false values. They can be declared like this and the word true or false will be highlighted. You can also declare boolean like this too. Is five greater than three? Yes, it is. So when you try to print this, it will come out as true. If a condition wasn't true, it would have printed out false like this. You can also check if two values are equal to each other with a double equal sign. Is 7 equal to 7? Yes, it is. So this will be true. You can also use greater than or equal symbols together. It's important to note that these relational operators can only compare numbers and strings. You can also check if something is not equal to another value like this. Is seven not equal to 8? Yes. So that's true. This comparison works for almost every data type. However, for tables, functions, threads, and user data. It compares our references in memory rather than their actual values. So you need to get a bit more creative when comparing them. You can also reciprocate building values by using a notgate with A being the input and Q being the output. If you print not true, it'll print as false. If you print not false, it'll print as true. Conditionals like these are typically used in if statements. If statements are block of code that only run when the condition inside of it is true. For example, if 9 is greater than 7, it'll print this. If that condition wasn't true, then this block of code would be ignored. Another example is if 1 is greater than two. This is obviously not true. You can see our program completely ignores this print statement. You can use an else statement to run a separate block of code which run only when all previous conditions are false. There's also else if similar to else. Else if blocks of code only run if the previous condition is false and the condition inside of it is true. You can have as many else if statements as you want. We can only have one else statement. Another logic gate you can use is the and operator. This operator checks for two conditions at the same time. It only be true if both conditions are true. For example, this block of code will only run if both of these statements are true, which they are. There's also an or operator which similarly check for two conditions. This will only run if this is true or this value is true or it will also run if both of them are true. It won't run if both of them are false. Functions. Functions are blocks of reusable code that can be run by calling them. We can declare a function by writing a local function and then a name for a function followed by two brackets and an end statement. You can also have a local variable equal to a function. They both do the same thing. You'll notice that nothing prints out here. This is because our program is compiled line by line. And when it sees the function, it skips past it. Only when we call our function like this will our program backtrack and then run the code inside that function. Functions are useful because you can pass in one, two, or more values as arguments. A function will receive these as parameters. Parameters like variables. And similarly, you can name them whatever you want and they'll be equal to whatever you pass in here. You can add these two values here since they're numbers. If you want the sum of these two numbers as a variable, you can return it like this. This is useful because whatever we return will be equal to the call of the function which we can set as a variable and print it. If this statement has no arguments, value 1 and two will be initialized as nil and we get an error on this line. Only because addition only works on numbers and not nil values. So let's remove that for a second. Something important to note is that when our program sees the return line, it will immediately exit the function from that line. So if we tried adding this print statement here, we'd get an error here because it's beyond the scope of the function. But why would this be useful? Take this example here. If we were to call this function, since the player has 15 coins, which is not less than 10, it will ignore that block of code and run the rest of the function. It will print this and take 10 coins away from the player. Suppose the player had eight coins to begin with. Since 8 is less than 10, the statement is true. So it print and return back to the call, skipping the rest of a function. What if you wanted to return two values instead of one? Well, it's important to note you can declare two variables of one line like this. It'll take value one and value two, making them equal to 10 and 15 and separating them with commas. You can see we made two variables of one line here. A similar concept works when you try returning variable 1 and variable 2 and separating them with commas. And if you try printing this call of the function, you'll see you'll get both numbers together. We can separate them by having two variables equal to the call of the function. And the variables are assigned in the order of a return. and how we can print them individually. Tables, arguably the most powerful data type. Tables are used to store multiple data types such as numbers, strings, functions, and even tables themselves. If we were to print a table, it would look like this. If you wanted to print the first item in our table, we can index our table with square brackets and passing a number which represents the position our value is in. If we were to index it of one, we get the first item. If we index it of two, we get the second item, etc. But if we try to index a third item, we get nil. Our program automatically initializes out ofbound indexes as nil. This is useful because if we wanted to add another item to our table, we can index a third item and give it a value. When we print our table, we can see our value has been added to it. You can use this to overwrite different values as well. Another way to add an item to our table is using table.insert. Table.insert is a built-in method that allows you to add an item to the next available index, which is useful if we don't know how many items are in our table. First parameter is our table and our next parameter is the value we want to add. As you can see, this number has been added to our table. Similarly, if you want to remove an item from the table, we can index individual items and make them equal to nil. Be careful though. If for example, we remove the second item from this table and the first and third item already initialized. The table pronounce item one nil and item three. Visible tables can't have gaps in them. So missing values will always show up as nil. Luckily, there's a table remove method which solves this problem. It takes in two parameters, the name of our table and the index we want to remove. We try removing the second item like before. You'll see it completely removes the gap in our table, which is very useful. If we wanted to remove the last item in our table and we didn't know how many items were in our table, we can index our table using # our table and set that equal to nil. This will always remove the last item of our table. If we try to print # our table, it'll print out free because there are three items in this table. Therefore, this line will always index the last item of our table and remove it. For tables, the index of the item is also called the key. If you want to add an item with a unique key, you can do this by wring the name of our table square brackets. Input a string and this string will be the name of our new key. Then make it equal to whatever value you want. You can also add a key by doing dot the name of the key then equal to whatever. They both do the same thing. It's just that with a string you can have spaces and special characters. And now you can see we have a unique key in our table. If you want to declare a table with a unique key beforehand, you can just write the key name inside the table and make it equal to whatever variable you want. Or you can use square brackets like our previous example. If we print this table, we can see our fourth item has a unique key which functions similar to a dictionary in other programming languages. If you wanted to remove this item from our table, we can't index it like we did before as this is a unique key and not a number. Instead, we'll have to index it using its key name and setting that equal to nil and then the item will be removed from our table. And just like with other keys, can print out the corresponding value by just indexing them. Before we cover the next data type, I want to quickly cover loops. There are three types of loops. for loops, while loops and repeat loops. This is a for loop. i= 1 is our starting index. This 1 is our step count. And this 10 is our final number. Every time a program reaches the last line of our loop, our index increases by the step count. It keeps looping until our index is greater than or equal to our final number, which in this case is 10. Since I is a value that's constantly increasing. If you print I inside of a loop, it'll print numbers from 1 to 10. If we were to increase the step count from 1 to two, it would print all the odd numbers from 1 to 10. And then increasing our final number from 10 to 100 would print all the odd numbers from 1 to 100. If you don't declare a step count, the program will just assume it's one. If we change a step count to zero or a negative number, nothing would actually happen. This is because Luo can detect this as an infinite loop and will ignore our loop to prevent it from crashing our program. We can also use loops to iterate through tables. Here we have a table. We declare two variables like this. I which is the index we're on item which will display a value in our table and then we pass in our table here. If we were to print item it would print all the values on our table one by one. This is because item is actually equal to our table index by i here. i increases by one each time we loop through this until i is equal to the total number of items in our table which in this case is three. But l initializes this as a variable which we can name here. In this case we named it item to represent each item individually in our table. It's important to know that I treat a little bit differently when looping through tables. If our table was a mix of numbered and unique keys, then if we tried printing I in our loop, it would give us the keys of our table and then the unique keys at the very end. No matter where our unique keys are in our table, they'll always be handled last. If you wanted to print out only our numbered keys, we can use a built-in method called IPAs and we can pass our table in here. This would only print out our numbered keys. There's also a regular pairs method, but as far as I can tell, it's completely useless for looping through tables as when you loop through a table on its own. L automatically uses pairs in the background. So, it won't matter. While loops while loops look like this, they're taking a boolean value here and they constantly loop until this condition becomes false. For example, if we use two is greater than one, this will simplify as true. However, this is bad as both these numbers are constants and therefore this condition can never break. These types of loops will loop infinitely and can be dangerous as they can crash your program. Let's use a variable. Every time this loop runs, this variable will decrease in value until the condition here is broken. As you can see, this prints out five times because after the fifth iteration, this condition is no longer true. So, it stops looping. Repeat loops. Repeat loops look like this. They're similar to while loops with two key differences. The first being with a while loop, the condition is checked before running the block of code. However, with a repeat loop, it checks the condition at the end of each loop. This means a block of code inside a repeat loop will always run at least once before a condition is met. And that leads us to the second difference. While loops will continuously loop until the condition becomes false. With a repeat loop, however, will continuously loop until the condition becomes true. There's also something called recursion, which is similar to a loop, but works a little differently. Recursion is when a function calls itself to repeat an action. Here we have a function called countdown and we'll make it take in a parameter called n which represent a number. Let's print n and if n is greater than one, we're going to call the function again. This time pass in n subtracted by one. This if statement is called the base case which will prevent the function from calling itself over and over to an infinite number of times. We can imagine how this function works if we were to call it down here and pass in a value. Let's pass in 8. The eight would go up here and then it would print 8 and since 8 is greater than one it would call the function again and this time pass in 8 minus 1 which is seven. Then it would pass in seven here and so on and so on until n is equal to 1 and since 1 is equal to 1 and not greater than it this condition will become false. Then our program could finally exit the function and no matter what number we pass in here it will always count down to one. Now this is a very simple example of recursion. Recursion is very similar to while and repeat loops. What sets it apart is that each function call can receive new arguments, allowing the function to build on its previous state. Because of this, recursion is often used for tasks such as depth first search and bre first search and traversing nested tables in general. Here's a more useful example of when we'd use recursion. Right now, what we want to do is print out each number individually in this table. But the catch is is that includes nested tables. Well, the way we can do this, we'll declare a function called print numbers and make it take in a value. We'll call the function down here and pass in this entire table. For our base case, we'll use a special type checking method called type of, which allows us to check what data type our value is. In this case, we want to check if it's a table. You could also use this method in future to check for different data types such as booleans or strings. If a value we pass in is a table, we're going to loop through it and call the function inside this loop, calling it for each item in our loop. If our value wasn't a table, this would mean it's a number, and therefore, we can print it out like this. And now if we were to run this program, it would print out all the numbers sequentially. And it doesn't matter how deep the nested tables are, it'll print all the numbers. Just keep in mind each time we call the function, it will be added to something called stack. Since our program does a new call for each value in our table, these call stack on top of each other. And if there's too many of them, our program may throw a runtime error, and we'd reach something called stack overflow. Stack overflow is quite rare of recursion as Lu's documented stack limit is 20,000 calls per thread, which is a very large amount. threads. An example of threads are co- routines. We can declare a co routine like this and pass in a function here. In order to run this, we need to use co- routine.resoom and pass in a cor routine here. And here we can see our cor routine is working. However, if we try to run this line again, you'll see it still only prints once. This is because our cor routine is dead. Coroutines have a special attribute called status. We can see what the statuses by writing corine. status and passing in our cor routine here. And if we were to print this before we run the resume line, we'll get the word suspended, which just means it hasn't run yet. If you print this again after the resume line, we get the word dead, which just means the corine won't do anything, even if you try resuming it. Inside a cor routine function, we can use something called corine.yield, which allows us to create increments of checkpoints inside the function. Therefore, if you run resume and resume again, then one more time, we can print these values one by one. And of course, if you do another resume, it won't do anything because our corine is now dead. Corines have four possible different statuses. Suspended, which just means the corine hasn't started yet or has paused. Running, which means it's running right now. Normal, which means a corine is resuming another corine. And dead, which just means the coroutine function has reached its end. If you were to print a corine status inside of its function, you're going to see it says running. Now, whenever a corine status goes to normal, it just means a coroutine is running another coroutine. And we can depict it like this with these two cor routines. We start by resuming the second one, which will resume the first. And whilst we're on the first, we can try to print out the status of coroutine 2. And as you can see, you get normal. There's also something called coroutine. It's similar to corine.create. But with coroutine. The corine can be called like a function. And as a result, you can return values too. It's basically just a normal function. But since it's a corine, you can add yields to add checkpoints to it like this. And just like other co- routines, it will die if the function reaches its last line. Do be careful though since we call the corine like a function. If you try calling it while the cor routine is dead and you'll get an error unlike with coroutine.res. There's also other ways to make threads such as task.spawn which creates a simple singular thread which ticks in a function as well which is one of the more common forms of threads. There's also taskde which runs but only when the main thread is finished running. There's also task delay which takes in two parameters a number and then a function and it will delay running the function by the number of seconds you put in here. There's also something called task.anc cancel, which can cancel any of these threads here, only if they haven't run yet, and they're most useful for canceling task or delay functions. This is extremely handy for making resetable timers. Here's an example of some code. Heal task is initially set to nil. When our function runs, this is a fancy way of checking if heel task is not equal to nil because if it isn't equal to nil, then it must be a thread in which the timer will get cancelled. Then heal task will be set back to nil. Then after that, you'd start a new 15-second timer. And then this code will run after 15 seconds, which will heal the player, which is super useful for important game mechanics such as combat tags and much more. There's also something called coroutine.unning, which can be declared into a variable. You can use it to check and access any C routine that's currently running in the background. Now, let's explain the main thread. The data type thread is a little bit misleading, and not to be confused with CPU threads. A better name for this data type is schedules. As in programming terms, you're not technically creating any new threads. A good example of a thread is this blue bar that executes code here. If you had multiple threads, then they'd be running in parallel, which is not what this data type does. All we do is slightly change the order in which code is executed in. Take this example. This is a while true loop. Added a tight to prevent our CPU from locking. If we add a print statement here, it won't print at all. This is because our thread is perpetually stuck in our loop. If we use a task.spawn here and put our loop inside of that function, you can see our print statement runs first before our loop. The way this works is that we'll wait to execute everything else first and then schedule our loop at the very end. If we have multiple while true loops wrapped around a taskspawn, it will schedule the priorities and execute them back and forth each time basically looping through these loops. It's very clear that they're not in parallel. It's still executed in serial, which just means line by line. And for the last data type, user data. User data is basically a custom predefined data type which are mainly in most game engines in Roblox. A good example of these are vector freeze, C frames, brick color, color free and etc. User data cannot be created in most game engines using their version of Lua alone. However, you can create your own user data in traditional LEA. However, you need to understand C or C++ to create real user data which I'm not going to explain in this video as it goes beyond our scope. Now that we've covered all data types, I want to briefly discuss the difference between global and local variables. Here we have an if statement. If you declare a global variable here, it can still be printed out here beyond the scope of this code. If we use a local variable, it'll print as nil, which is better as it can prevent our variable from being redeclared on accident. But let's say we have two variables in the very outer scope of our code. That mean they both act similar to global variables, right? Since the scope reaches the entire program or yes the scope does reach the entire program but local variables are still much better to use. To understand why we need to see how Lua actually runs behind the scenes. Lure code is executed by something called the Lure virtual machine. This virtual machine is written in C programming when Lua runs our code. Local variables are stored directly on stack. This makes them very easy to access since the virtual machine doesn't have to search for them. It knows exactly where they are in stack. Since global variables are global and their scope reaches the entire program even before they're declared. A virtual machine has to store it a little differently. It gets stored in a special table called env which is short for environment. Whenever your code has to access a global variable, the virtual machine has to look up using its hash key which is slower relative to local variables which can be accessed directly from stack. So even if both these exist at the top level of your code. Locals are still faster and more efficient. Anyways, that's all of luau. If you feel there's anything I've missed, feel free to leave a comment down below asking any question. Anyways, that's all. Thank you for watching and I'll see you in the next video.", "scraped_at": "2026-01-08T15:05:29.159465", "error": ""}