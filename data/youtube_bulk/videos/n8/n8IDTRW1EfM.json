{"id": "n8IDTRW1EfM", "title": "Why YOU Need A Module Loader | Roblox Studio", "channel": "Ludius", "views": 24564, "duration": "10:27", "url": "https://www.youtube.com/watch?v=n8IDTRW1EfM", "query": "roblox scripting tutorial", "transcript": "Let me ask you something. Does your workspace look something like this? >> Oh, hell no. >> Because if it does, then you got severe organization issues. And I don't blame you. In the YouTube space, which is where I'm assuming you're learning most of your scripting from, people don't really tell you about what's the best way to optimize your code or what are the most common practices used in this space. Listen, bro, you can't have your workspace looking like this. This just looks disorganized. If I wanted to commission a scriptor and I see their organization looking like this, you'd be immediately disqualified. Something that's a lot more attractive is using module loaders. And if you don't know what module loaders are, then pay close attention to this video because I'm going to put you on some serious game right now. Even though this is going to be more of a quote unquote boring tutorial because of the content of it, I promise you that learning module loaders is something that you will definitely not regret. I cannot stress this enough. Ever since I learned them, bro, I've been using them nonstop, bro. I'm serious. Every single project that I've created so far is using my module loader system. It's that strong. But yeah, I feel like I'm yapping too much, right? So, let me shut up and start the video that you actually came here to watch. Section one, introduction to module loaders. I think that the best way to start is by explaining what exactly is a module loader, what it's used for, and its advantages, right? So, let's start there. A module loader is an infrastructure system that makes organizing and utilizing your scripts in your game a lot easier. As its name clearly says, it uses module scripts. And I'm assuming you already know what a module is, but if you don't, it's just a script that doesn't run by itself by default. And also, the contents of it can be accessed by other scripts by requiring the module script, which just returns whatever you're returning in that script. I'm not going to explain it any further than that. If you need further explanation, then go and do some research on it. But yeah, back to module loaders. Their way of organizing your scripts through the use of module scripts. What does this mean? Instead of using the popular local scripts and server scripts, you do almost everything in module scripts. If you know about module scripts, this is where you're going to start saying, \"Well, Ludius, if I put all the code in modules, the code won't run because module scripts code doesn't run by default when the game starts and it's used to store data and blah blah blah.\" And you know what? I ain't going to lie, bro. It's a valid concern. But here's how module loaders work. They have mostly module scripts, but they also have one local script and one server script, and they both require all the scripts that are available to them and run them. This way, all your code will run when the game starts. Obviously, the scripts need to have some code and a certain structure to them so that this is possible. But I'll show you all that later on the video. But hopefully you get the general idea of how this works. Section two, its coolest advantage. In my experience, module loaders open the door to a couple of very cool possibilities, but by far the coolest advantage is that you'll no longer need bindable events when coding. Ever since I've started using module loaders, I haven't used bindable events once. And if you're a beginner, I know I got your full attention now. You're probably so confused, but don't worry, bro. I got you. Since most of your code is in module scripts, then that means that most of your scripts will be able to require each other and use each other, which is what bindable events are used for, making these absolutely useless, unless you're prototyping, but even then it's kind of meh. Section three, setup. All right, now let's talk about the setup. Every module loader is divided into at least three sections. It's server section holding all the scripts that are going to be accessible by the server, and it also contains a script that requires and runs all the script. We'll call this the loader script. All of this goes inside a folder that goes inside service because that's a server exclusive section. Then there's its local section holding all the scripts that are going to be accessible by the client and exclusively by the client. And it contains a script that requires and runs all the scripts just like the server section. So yeah, this also has a loader script. All of this goes inside a folder that goes inside replicated at first because that's the client exclusive section and it also has its global section holding all the scripts that are going to be accessible by both the client and the server and it also has an initiator module script which is what the previous two loaders make use of. All of this goes inside a folder that goes inside replicated storage because that's the shared section. So both client and server can see this. So how does this look on studio then? It looks like this section 4 code. Okay. Okay, now into the content of every single script in the module loader. So here you have the loader scripts and all the other scripts we can call the host scripts because they're being kind of like hosted by the module loader. I don't know if that makes sense. Hopefully it did. Let's get the content of each loader script first. Both the local script and the server script loaders have the same content. So they both get replicated storage. Then the global module loader folder and then they get and require the loader that's inside that. After that they call a function inside the global loader module called load all. Why do they both do this? Because the logic that really matters is going to be inside the global loader module. In this script is where the real magic happens. This script first of all gets run service because that's what we're going to use to detect whether this script is being run by the server or the client. Why is this important? Since both of these scripts use this so that they can load all the modules, we need to filter which modules the client can run and which modules the server can run. Because remember, they're in different places. is there are going to be certain scripts that are going to be exclusive to the client and other scripts are going to be exclusive to the server. How do I know which ones can run on the client and which ones can run on the server? Well, first of all, the ones in replicated storage should be able to run both on client and on server. Hence why I refer to them as global scripts. Client can only see the ones in replicated first and the server can only see the ones in server script service apart from the replicated storage ones. That is so the client has to run the scripts in replicated first but also in replicated storage and the server has to run the scripts in server script service but also in replicated storage as well. The logic that detects which scripts can run is done here in the script. So as I said the first thing we get is the run service for that. After this we can start with the main function load all. Inside this function the first thing we're going to do is get the global scripts folder. Then we create a variable that will hold the specific folder containing the scripts depending on if it's client or if it's server running the script. So, we're just going to create that variable and set its value to nil for now. Moving on, we'll get to one of the most important parts. We set an if statement to determine if the current script is being run by server. And we also add an else- if check to see if it's run by the client. These two ifs have different content. Of course, if the server one, we get the server scripts folder, and we set the server or local scripts variable equal to the server scripts variable. On the client one, we get the client scripts and set the server or local scripts to the client scripts variable. And with this, we now have the folder of the scripts that it has to run regardless of if it's running on the client or server, which is our variable RS scripts. And we also have the client exclusive or server exclusive scripts folder that it needs to load, which is our server or local scripts variable. Now, we got to load all of them. And we'll do that by iterating through both of these folders. Checking if what it's iterating through is a module. If so, we require that module. We check if that module has an element called unload, which should be a function. More on this in a bit. Stay with me here. And if it has that onload, then we call that function. I know you might be a bit confused because of the onload function, but I'm going to proceed to explain that. Now, this has to do with the scripts that your module loader will be hosting. Let's take test global script for example. Ignore the test global script 2 variable thing for now. I want you to see how I added a function to this module table. Yes, you can add functions into module tables like this. I prefer to do it like this because I think it looks cleaner, but whatever way you add function works. The point is this module needs to include a function called unload. and the content you want the script to run at the start of the game goes here inside the unload function. As long as you have that function and you call it from the global loading script, whatever code is inside this unload function will run whenever your game starts. All I have inside this script is a print that says the name of the script in brackets and then loaded after it. If I go ahead and test this now, the first print we get is this one. Test global script loaded. And just so that you see that I'm not pretending or something, if I click this print, it takes me right back to the script that this print is from, which of course is test global script. So, as you can see, it's working. I have other similar scripts with similar content. That's why you can see more prints. For example, you can see test global script 2, the one from test server script, prints from test global scripts. And again, I'll explain this in a bit. And the last print is just the one from test local script. All of these prints right here are not random, neither in order nor in repetition. The reason why the test global script and test global script 2 print repeat is because remember that the server and client both run the scripts that are in replicated storage. That's how it's set up. Therefore, we get two prints. Now, I'm explain why we're getting these two prints. The ones from test global script 2 test function call. First off, we already know the reason why we get two. These scripts are replicated storage. But where do these prints come from? Well, if you click any of these, it'll take you to the source, right? Test global script 2 has another function inside it called test function which I'm calling back in test global script. The test functions here do not run when the game start. The only one that does is the unload. So then what's going on with this function? Well, this is the interesting part. You can have here pieces of code that can be run by other scripts as long as you connect them via functions. This is an example of two scripts communicating without the need of bindable events. Test global script is using code from test global script 2 without the need for a bindable event. You can have as many functions here as you want. That's what's so cool about module loaders. Now you can communicate between scripts that are being run in the same place, meaning both scripts on the client or both scripts on the server without having to go through the whole bindable events. Then you just require the module you want to use like I did at the top. And you have access to all of its functions, but not only functions, you have access to other types of data that the module might be offering. And yeah, that's why we're getting those two other prints. Hopefully, you were able to understand this. I think it's pretty cool. Also, something to note here is that not all your scripts have to have the unload function. Sometimes you don't want the script to run any code when the game loads. Sometimes all you want it to do is just to hold data or hold code so that other scripts can use it later, which is fine, too. Conclusion section. All right, bro. Listen, this is just surface level stuff when it comes to module loaders. You can have other very cool customization features for your module loader. Like for example, making specific scripts run before others. Not going to lie, that's the only thing that comes to mind right off the bat, but but I'm sure there's more you can do with this. This is just how I manage my module loader simplified into the most digestible format so that you can consume it can customize yours however you want if you're feeling bold. Also, let me shout out Nstromus Bro's a real one. He helped me understand module loaders a lot better. He has his own module loader and it's open source to the public by the way called Cisco. The link will be in the description. I might have to do a tutorial on it on the future, but we'll see. If enough people ask me for more advanced module loader videos, I might just have to. So, leave a comment on what other videos you'd like to see. All of this being said, keep leveling up, bro. Be safe and I'll see you when I see you. Peace. >>", "scraped_at": "2026-01-08T15:05:19.238651", "error": ""}