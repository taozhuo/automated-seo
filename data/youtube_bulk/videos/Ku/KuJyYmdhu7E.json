{"id": "KuJyYmdhu7E", "title": "How To Script In ROBLOX Studio! (EASIEST Beginner Scripting Tutorial)", "channel": "RoDev", "views": 484962, "duration": "42:14", "url": "https://www.youtube.com/watch?v=KuJyYmdhu7E", "query": "roblox scripting tutorial", "transcript": "I can guarantee you'll be able to Script by the end of this video! This guide covers all of the Scripting essentials, and you can always come back to this video, whenever you need it. Feel free to jump around using the chapters (timestamps in description, too.) Let's get started! The very first thing you wanna do is go to \"Roblox.com/create\" Once you're on this website, download Studio by pressing the \"Start Creating\" button. Once you've downloaded Roblox Studio, it's going to open up, just like this. Once it's downloaded and open, you will need to sign in. After that, create a brand new \"Baseplate\". Once you've created a brand new Baseplate, close all the tabs that you don't need. Make sure to have the \"Explorer\", \"Properties\", and \"Output\" windows open. In the \"View\" tab at the top of the screen, you can open these windows. I have my \"Explorer\", \"Properties\", and \"Output\" windows open. First, delete the spawnpoint, then create a \"Part\". To do this, press the plus button on the \"Workspace\", then click on \"Part\". This spawns in a little Part for us. Go to the \"Home\" tab and select the \"Scale\" tool to change the Part's size. If you were watching closely you can see in the “Properties” that the “Size” property has changed. If you look at some other properties, you can see what the “BrickColor” is, if it’s casting a shadow, what the “Material” is, and the “Transparency”. If you’d like, you can go ahead and mess around with these properties a little bit. As you can see, when I move the “Transparency”, it makes it more transparent. When you change the “Material”, it changes what the Part looks like. For now, I’m going to keep the default settings and create a brand new “Script”. Let’s create a “Script” inside of the “ServerScriptService”. Click the plus next to “ServerScriptService”, then create a “Script”. Make sure it is NOT a “ModuleScript” or a “LocalScript”. Make sure it is a normal “Script”. When you create your Script, you are going to see: print(”Hello world!”) This is what we call a “Print Statement”. Now that you’ve created your Script, you’ll see it in the “ServerScriptService”. All these things like the “Baseplate”, “Part”, and “Script” are called “Objects”. Even this “Texture” right here is an Object in the “Explorer”. If your Script isn’t open, double-click on it to open it up. Next, let’s look at Printing. Printing is one of the most basic concepts in Scripting. As you can see, it says: print(”Hello world!”) This “Hello world!” is inside these two quotation marks. Whenever something is inside two quotation marks, it’s a “String”, as it says right here. This right here is considered a “String”, because it is a piece of text. If you run your game right now, it will say “Hello world!” inside the Output. To run the game, click on the arrow (below “Play”) and click on “Run”. This will run all the Scripts without actually spawning you in. As you can see, it says “Hello world!” right here, and it tells me where it came from. If I click on the Script button right here, it brings me to the Script that printed “Hello world!” In addition to that, it also shows me what line it was printed on. This is helpful when you have a really complex Script and you’re trying to debug your code. For example, if your code is stopping somewhere, and it’s not telling you where it’s stopping, you can place Print Statements in the code to find out where the code stopped working. Next, let’s look at Data Types. There are a few Data Types I want to go over. The first one is a “String”. This is a really simple string right here. Inside two quotation marks, you write some text. That’s pretty much all there is to Strings. Another Data Type is “Number”. Numbers don’t go inside quotation marks. This is because they aren’t Strings. Any number I type in here will be printed when I run the game. As you can see, as I type this number in, it’s printed in the Output. There are a few more Data Types, however, the last one I wanna look at right now is a “Boolean”. Whenever you see these check boxes in the “Properties” window, these are “Boolean” values. For example, if I go to the Part and I enable “CastShadow”, there will be a check mark (which means it’s turned on). When I disable it, there is no check mark. This means, when I click on it and there’s a check mark, I just set the “CastShadow” property to “true”. And that is what Scripting really is. Scripting is basically changing different Properties at different times. Now, let’s rename this Part. Inside the “Properties” window, look for “Name”, then change it to “BluePart”. Next, go to the “BrickColor” property, click on it, then change the BrickColor. I’m gonna change it to the “Electric blue” color. Now you can go back to the Script by clicking on it (at the top of the screen) or double-clicking it in the “ServerScriptService”. Here, we can change the same properties. To do this, type: game.Workspace (Which means you’re going from the “Game”, which is everything then ‘selecting’ the “Workspace”, and then “BluePart” to ‘select’ the Part.) Current code: game.Workspace.BluePart “Lua” is a case-sensitive language. That means, all of these capital letters NEED to be capitalized. If I were to type this with a lowercase letter “b”, it’s not going to work because the actual name of the Part has a capital letter “B” in it. Next, I’m going to type: .CastShadow = false This may be a bit confusing right now, But what I’m doing is setting the “CastShadow” property to “false”. If you remembered what I just said, that means when you click on this Part, and look at “CastShadow”, this checkmark will not be there. Let’s go ahead and run the game to see if the code works. When we click on the Part, we can see that the “CastShadow” property does not have a check mark. This means that “CastShadow” is set to “false” (meaning it’s turned off), which is what the Script updated it to. Next, let’s learn about “Variables”. Before we learn how to create a “Variable”, The first thing I wanna show you guys is exactly why we use Variables. I’m going to change the “CastShadow”, “Transparency”, and “Material” properties of this Part. As you can see, the “Material” of this Part is “Leafy Grass”, the “Transparency” is 0.5, and the “CastShadow” property is “false”. I did this in the Script by typing these three lines of code. So remember, it goes: game.Workspace.BluePart.CastShadow And the same thing applies for the other lines of code. It goes through the whole Game, then we select the Workspace, then we select the “BluePart” inside of the Workspace, and then it’s going to look for either a “child” / object inside of the “BluePart”, or it’s going to look for a property of the object. Since there is a property called “Transparency”, it’s going to update its Transparency. The same thing with the Material, it went to the Part, and then it looked for the “Material” property. However, this is a lot of code to write out. Let me show you all why we use Variables. All I have to do is type: local part = game.Workspace.BluePart and then under here, all I have to do is type: part.CastShadow = false part.Transparency = 0.5 part.Material = “LeafyGrass” (or Enum.Material.LeafyGrass) Now I'm going to delete this code. And as you can see, this is a lot easier to write. The word “local” tells the Script that we are going to name a variable. I named my variable “part”. You can assign the variable to something by using the equals sign (=). I made sure that the “BluePart” in the Workspace “becomes” the Variable. The “BluePart” is another data type. It's called an Object (or “Instance”). On the first line of code, the Script “learns” what the “part” Variable is. It knows that out of the whole game, you go to “Workspace” and then you go to “BluePart”. From there, it knows what the “Part” Variable is talking about. After that, whenever you say “part” (the Variable name), it knows that the “BluePart” is what it's looking for. If we put “game.Workspace.BluePart” right over here, it will do the exact same thing. However, we are making it a lot easier by typing this line of code (the Variable), which tells the Script that all of this can just be replaced with “part”. If you remember when we talked about Data Types, one of the types we talked about was a “String”. The cool thing about Variables is that they can equal any Data Type. I named this variable “CoolString”, and I set the value to “Hello there!” I also made sure it's inside these quotation marks to make sure the Script knows it's a String. Without the quotation marks, the Script doesn't know what “Hello” or what “there!” means. However, inside the quotation marks, it knows it's a string. The cool thing about this is we can type the variable name inside the Print Statement and this will print “Hello there!” If I run the game right now, you'll see that it says “Hello there!” in the Output. I can click on it right here, and it also tells me the line number right here. It brings me right to where it printed from. Next, let's learn about how the Explorer works, and what Object Oriented Programming (OOP) is. By now, you know what an object is. These things inside the Explorer are called objects (or Instances), and they can have “Parents” and “Children”. A good way to explain this is to look at the “Camera”. This camera is a “child” of the Workspace, the Workspace is a “parent” of this “child”, and this “child” is the Camera. Once again, this Texture is a “child” of “Baseplate”. It is not a “child” of Workspace because its “parent” is the Baseplate. Baseplate’s “parent”, however, is the “Workspace”. You can tell what an object is parented to and what children it has by looking at the indentation. This folder right here is indented twice. Its parent is the Camera, not the Workspace. We'll learn about this later, but this folder right here is actually a “descendant” of the Workspace. It is not a “child” of the Workspace. However, we'll be learning about that later. The next thing we're going to be learning about are “Instances”. So far, you've learned about objects, printing, but now I want to make you all more comfortable with the Script editor. So go ahead and open up your Script, delete the code, and type this: Instance.new(”Part”) What this line of code does, is it creates a new object and that object is a “Part”. “Instance.new” will create the object, and inside the parentheses, you want to specify in a string, what you want to create. However, the issue is, when you run the game, you're not going to find this Part anywhere, and that's because its parent is currently “nil”. We see inside these objects that their Parent property are set to whatever they’re Parented to. For example, this Baseplate is parented to the Workspace. However, this Part has no parent right now. That means this Part's parent is “nil”. What we did here was add Instance.new(”Part”) to a variable. So now whenever we type “newPart”, it's going to be referencing this Part that we created. You never actually type “Instance.new()” by itself. You always make sure it's assigned to a Variable, so you can actually edit the instance that you created. When I say “edit the instance”, I mean changing its properties. For example, the first thing you do when you instance something new is you change its “Parent” property. Currently the parent is nil. That means you're not going to find it in the Explorer. It's currently parented to nothing. Let's go ahead and put this in the Workspace. To do that, let’s change “nil” to “game.Workspace” Now if you run your game, you're going to find the Part in the Workspace. As you can see, the Part is right here. Next, let's change its “Name” property. This is really simple to do and I know you all can do it with the knowledge that you've gained so far. Type: newPart.Name = And then now you need to type in a String. That's because the “Name” property is a String. I named it “CoolPartThatICreated”. Let's run the game to see if it worked. As you can see, the part's “Name” property has been set to “CoolPartThatICreated”, and that’s because of the Script. Now you may be wondering, “what else can I do with Instance.new?” “I don't just want to keep creating Parts.” Well, for that, you're going to need to look at the “Object Browser”. To open up the “Object Browser”, go to “View” and open it up from the left side. After future updates, it might not be here anymore. Just look around and you'll find it. The object browser is amazing! It contains everything you can really do in Scripting. For example, if I ever need to use “Sparkles”, I can find them here and it gives me a summary. It also tells me what it is (it's an Instance). In the top right, you'll find things we can do with the Sparkles. For example, in the Script, if we want to destroy some Sparkles, what we could do is destroy them using this Function “:Destroy()”. You'll learn how to do that later. Let's say I wanted to run some code when the Sparkles got destroyed. In the Object Browser, I can see that there's an “event” for when they get destroyed (”Destroying”). Basically, if there's an “event” for it, I can add code to that. That means that when the Sparkles are destroyed, this event will go off, which means I can run code. If that did not make any sense to you, don't worry. We're going to be learning about “events” in just a little bit. Right here, I found the part. If you scroll down to these blue blocks, you'll see all the properties that we've been looking at. For example, you can see the “BrickColor” and “Transparency”. The Object Browser is great because you can see all the events, Functions, and properties of every object in the game. This can be really helpful when you're Scripting or if you're stuck. And one more thing! If you don't know what something does, you can always find it in the Object Browser and read the summary. The next thing we're going to be learning about is Math. Math is really important because everything the computer reads is in numbers. For example, the “Color” is simply a number. “Position” and “Size” are also numbers. All the text, like the “Name” and the “Parent” become numbers when the computer reads them. It's really important to know Math when Scripting, so make sure you understand this next part. I'm going to remove all of this code and create a new Variable. I'm going to call this: local number = 5 Inside of a Print Statement, I'm going to write: print(1 + number) Let's go ahead and run the game. Obviously it's going to print “6”. This happened because we told the Script that “number” equals 5 and then we added 1 to “number”. The Script read this line of code just like this, except we saw it like this. This right here (+) is a plus sign. Let's try different operations, like subtraction. Running this code gives us -4 To divide in Scripting, use a slash (/) 1 / 5 equals 0.2, that’s why it gave us “0.2” To multiply, press “Shift” and press “8” that's going to give you a star. That will give you a star (*, an “asterisk”). 1 * 5 equals 5, which is why it gave us “5” Now that you know the four basic operations, I’ve listed out the operations here in case you need to see them. I know you guys understand Variables by now, so I'm going to stop using them and just do some math here. This code right here gave us 100 because 10 * 10 equals 100. However, if I were to use a slash, which is for division, it would give me “1” because 10 / 10 equals 1. There isn't much else to say here because basic math is really simple in Scripting. You have these four operations and you can do anything you want with the numbers. To wrap this section of the video up, I'm going to create a number using math and then apply that to the Part’s Transparency. In case you are still confused, I’m going to explain this one more time. When I write “game”, I'm referencing this entire game. All of these things right here are actually children of the game. From there, what I'm doing is “game.Workspace” because Workspace is a child of the game. The next thing I need to do is grab the “BluePart”, which is a child of the Workspace. We can also confirm this by looking in the properties of the “BluePart”. You can see that the parent is the Workspace. So I'm going to write “Workspace.BluePart”, and now we want to adjust the Transparency property. So I'm going to write “BluePart.Transparency”. By the way, you can also press “Tab” to autofill it. That just makes Scripting a little easier and faster. Now I'm going to use equals (=) because I want to set it to something. I'm going to write “newTransparency” because the Script knows that “newTransparency” equals 0.5 Let's run this and you'll see the Part’s Transparency is 0.5 That's about it for math. Let's go ahead and see how you can use “Print Statements” to find errors. Let's learn about the “Output”, errors, and how to counter or fix errors. By looking at the Script, it's pretty simple what it does. First we find out where the “BluePart” is and then we tell the Script that “part = game.Workspace.BluePart” Remember, we go to “game”, then “Workspace”, and then to the “BluePart”. From there we're looking at the Part’s Transparency. The Script sets it to 1, then 0.3, 5.6, and then we have a Print Statement. This will let us know that the Script made it to this line. If you didn't know what happens, when we have an error, the Script stops. From there, it's going to line #9, #10, and at line #11, there’s an error. From there, the Script will stop and this line will never run. To show you this, I'm just going to go ahead and run the game. As you can see, we did get an error here, but let's look at the Print Statements. The only Print Statement we can see is “Line 8”. Now, I do know it's showing us where the error is, and what line it occurred on, but sometimes, you won't see this. That's why it's important to know how to do this. So remember what the Print Statement says, stop the game, then look at your Script. As you can see, “Line 8” was printed right here, However, “Line 12” was never printed. In order to fix this error, for each individual line, I’ve added a Print Statement. After running the game, we can see “Line 8”, “Line 10”, and “Line 12”, but we don't see “Line 14”. This means, that inbetween line 12 and 14, the error occurred. That leaves line #13. As you can see, we found the error. From here, you would take a look to find out what's wrong. I spelled “Transparency” wrong and we're using a Data Type that won't work here. We need to use a Number instead of a String. And by the way, this won't even work as a String. It needs to be inside quotation marks “ ” Next, let's take a look at something really really useful... Functions! You’ve learned about Variables, but what if we could take it one step further and make all of this code easier to write? That's why we use “Functions”. This right here is a Function that I created. I named it “changeTransparency”. Inside of it is a “Code Block”, and right here, we can write any code we want. I'm going to write: part.Transparency = 1 Now you'll notice that if we run the game right now, nothing is actually going to happen to the part. As we can see, the part is still visible. So let me explain why that happened. So far, we've declared the Function. We told the Script to run the code inside the code block whenever we call the Function. This means we have to call the Function to run the code. To do that, type: changeTransparency() (What you named the Function) and then run the game. And just like that, the part is invisible. It's highlighted right now because I've selected it in the Explorer, but if I deselect it, it's invisible. Now you might be wondering, “Why don’t we just write this line of code again and again and again? It seems a lot simpler than having to write extra code to create a Function.” So let me show you guys why we actually use Functions. Let's learn about “Parameters”. Parameters are really really simple. I'm going to create an example and then explain how it works. I created a Parameter called “number” and I set the “Argument” to “1” when calling the Function. Let's run the game and you'll see that the part is invisible. The part is invisible, Now let's go and find out why / how Parameters work. Right here, I have a Parameter called “number”, and in the Script I can use “number” whenever I want. However, if I don’t tell the Script what number, it's never going to know what to set the Transparency to. That's why when you call the Function, you have to use an “Argument”. For my Argument I put “1”. This means, when the Script runs the code, it's going to go to the Function, which will make “number” equal 1. So when it runs the code, it's going to see the code just like this. It's not going to see the code like we see it. It'll see it with the 1. And that's because we provided the Argument “1”. We can take this one step further and add multiple Parameters. I'm going to call this Parameter “number1”, and this Parameter “number2”. I've changed the Function name to “addNumbers”. We don't need this Variable, so let's get rid of it. As you can see, I have “number1” and “number2”, and in the Function, I'm adding the numbers and printing them. If I were to run this code, it's going to print “3”. The Script added “1” and “2” together and it printed “3”. If you're following along, you'll know why this works. “number1” became “1” and “number2” became “2”. Then the Script added them together in the Function. Remember, these can be anything. So I can make this “67” and I can make this “5”. And when I run the game, it's going to add the two numbers together. It printed “72” because the Function added the numbers together. Now I'm going to show you a real example using multiple Parameters. Right here, I created two parts. This one is called “RedPart” and the other one is called “GreenPart”. Now let's say I wanted to change its Transparency. For this, I would create a brand new Function called: “ChangeTransparency”. Inside the Function I would add the code, but there's an issue! I only want to use one Function. However, if I want to adjust both parts, I would have to create multiple Functions. To combat this problem, we can create a Parameter for the part. Along with that, I created a Parameter for the Transparency. Now, all we have to do is type: part.Transparency = Transparency Below this Function, I'm going to call it. Let's put the “RedPart” in first, but before that, let’s create our Variables. local redPart = game.Workspace.RedPart local greenPart = game.Workspace.GreenPart After that, I'm going to input the “RedPart” as an Argument. If you haven't picked that up already, These are “Parameters” (in the parentheses of the function) When you input them (when calling the Function), they're called Arguments. I called the Function with the “redPart”, turning it into the “part” Parameter in the Function. As you can see right here, we set the Variable and the Transparency as “0.4”. Let's run the game and you'll see the “redPart” now has a Transparency value of 0.4. It's a little hard to see with the lighting, but if we look really closely, it is transparent. In the Properties, the Transparency is 0.4. Now I'm going to do the same thing for the “greenPart”. All I’ll do is change this to “greenPart”, and make this “0.9”. Let's go ahead and run the game. As you can see, the RedPart’s Transparency is 0.4 and the GreenPart’s Transparency is 0.9. This is one of the most basic ways I could explain Functions and Parameters. So if this is helping out so far, let me know by leaving a like on the video. Next, let's learn another feature of Functions, which is “Returning”. Like pretty much everything else in this video, “Returning” is very, very useful. Sometimes, Functions don't just change things in the game. Functions return values. This means you can use Functions to do something like math, and you can have the Function give the answer back. Let me show you what I mean. The code you can see right now prints “3”. It might not be obvious how it works right off the bat, but let's take a look. The first thing I'm doing is creating a Function. You already know how to do this. We have Parameters right here, and the Function will do something with the Parameters. In this case, we use “1” and “2”. That means “A” is 1 and “B” is 2. So the Function did what it did with the Arguments that we put in, and after that it did something new: It returned “x”. Remember, “x” can be anything. If this was “r”, it would be “r” here. And if this was “v”, it would be “v” right here. However, in this case, I used “x”. What's happening here, is the Function knows “a” is 1 and “b” is 2. (When I run it from here) What the Function is doing, is adding “1 + 2”, and then it's setting a Variable “x” to the answer of “1 + 2”, which is “3”. Then, the Function is returning “3”, and then the “addednumbers” Variable becomes “3” and we end up printing “3”. Essentially, what happened is this turned into “3” and then the game did what it did, knowing that “addednumbers” equals 3. If I were to change this to “4” and “5”, it would print “9”. Just like that, it printed “9”. Let's run through it once again. First, I'm setting up a Function, then I'm setting the Parameters “a” and “b”, we're adding the Parameters “a” and “b”, and we're setting that value (whatever “a + b” is) to the “x” Variable, and then the Function is returning “x”. That means this entire “Function call” turns into “x”. Now you might be wondering why “x” is underlined. Let's learn about “Scope”. To explain “Scope”, I'm going to be creating two Functions. I've set up two Functions. At the top, I defined “x” as “1”, and then for the first Function, I printed “x” as well as in the second Function. After that, I ran both of the Functions. We already know what this will do. It's going to print “1” twice. As you can see, the Script printed “1” twice (On line #4 and line #8) Looking back at the Script, on line #4 we printed “x” and on line #8, we also printed “x”. Now if I were to take this “local x = 1” and just move it into this Function right here, this “x” down here is actually underlined. If I run this, it's going to print “1” and “nil”. If you remember from earlier in the video, “nil” means “nothing”. It's the Script's way of saying, “I don't know what to put here” (or, “Variable x does not exist / have a value”) “I'm just going to put no value” along with that, before we run the Script, it's also telling us that it doesn't know what “x” means. So you might be wondering why this happens, because we did define “x” as “1”. For some reason, this Function is unable to pick that up. Well, “Scope” kind of works like this: Whatever happens inside this Function will stay in this Function, and that's because of the word “local”. We've been writing “local” this whole time, not really knowing what it means, but now we're learning about “Scope”, so let's dive into that. When I define “x” inside this Function, and the Script reaches line #5, it “deletes” (or “forgets”) what it learned inside line #2 and #3. When I define “x = 1” in the Script, using the “local” keyword, the Script “deletes” everything from inside this Function that it knows, by line #5. Once it reaches line #5, it doesn't know what happened on line #2 and #3. That's why when the Script reaches line #7, it doesn't know what “x” means. However, if I were to remove the “local” keyword, as you can see, the Script now knows what “x” means. If I run the game, it's going to print “1” twice. Just like that, the Script printed “1” twice. That's pretty much all there is to the basics of “Scope”. One more thing to mention, is that when you have a Variable at the top of your Script just like this, the entire Script can access that Variable. So it doesn't matter if it's local or not, the entire Script is able to access that Variable because it's not inside of a block of code, it's not inside of a Function, a loop, or an “if statement”. Speaking of “if statements”, let's go and learn about them. “If Statements” are very, very simple. Since Lua is written almost like English, it’s really easy to learn “If Statements”. For example, let me write one. This “If Statement” right here checks if “x” equals “1”, and then it prints “X is equal to one!!” When I run the game, in the Output we see “X is equal to one!!” However, as you might have guessed, if I change this to “2” and run the game, it's not going to print that. Stating the obvious, the reason for this is because Variable “x” is equal to “1”. Here, we're only running this code if “x” is equal to “2”. One more thing you may have pointed out is that there are two equal signs here (==) The reason for this is we are doing a “check”. When we're setting a Variable to something, use one equal sign (=). For example, I'm telling the Script right here, “x = 1” However, over here, I want to check what the value of “x” is. So what I'm doing, is: “if x ==”, and then what I want to check for. In this case, I'm checking for “2”, and since “x” does not equal “2”, this code will not run. One more thing I want to show you is checking for “not equal to 2”. There should be a button above “Tab” (to the left of 1) around that area on your keyboard. If you hold “Shift” and press it, you're going to get this symbol right here (~). One of these next to an equals sign means “not equal”. That means, this code will run if “x” is not equal to “2”. By running the game, we'll see in the Output that “X is equal to one!!” However, “if statements” alone provide limited functionality. Let’s see what “else statements” can do. Compared to “if statements”, “else statements” are actually really really similar. Let me show you all how to use an “else statement”. Let's change this back to “x == 1”. And right here, we're going to change this “end” to “else”. After that, press enter, and it's going to create an “end” automatically. If it doesn't create an “end” automatically, something might be wrong. Make sure you fix it. What I've done here is set “x = 2” and wrote this print statement that says “X was not equal to one!!!” If I were to run the game right now, you can already tell that it's going to print this statement right here. You can already tell it's going to print this one right here. Just for proof of concept, I ran the game, and as you can see, it says “X was not equal to one!!!” “Else Statements” are really simple, and they're really easy to combine with the last section of the video, where we talked about “if statements”. However, another addition we can make to “if statements” are “elseif statements”. Let’s learn about them. “elseif statements” do the same thing as “if statements”, but you can use them to “extend” an “if statement”. As you can see, we can type “elseif” and then we need to input another condition. Similar to how we have “x == 1”, I can make this something like “x == 2”. After that, write: then (so it looks like “elseif x == 2 then”) If you read this as if it was in English, you would be able to understand it because Lua is really similar to English. Let's go through the code. If “x” equals “1”, then it will print “X is equal to one!!” However, if “x” is not equal to “1”, it's going to go down and continue on to the “elseif statement”. Then it’s going to check if “x” equals “2”, and then it's going to print “X was not equal to one!!!” only if “x” is equal to “2”. However, if none of these are true, it will default to running the code in the “else statement”. Once again, we can take a look at this. When “x” equals “1”, it'll print this. When “x” equals “2”, it'll print this. However, if none of these conditions are met right here, then it's going to go down and print this. Let's set “x” to “3” and run the game. As you can see, it prints “X is not 1 or 2!!!” Now let’s try it again, but set “x” to equal “2”. As you can see, it prints “X is 2!!!” Something similar happens when “x” equals “1”. It's going to print “X is equal to one!” Just like that, it printed “X is equal to one!” (on line #4 of the Script) Also, if you end up with these circles on a Script anywhere and you click on them to try to make them go away, know that these are “Breakpoints” and they will cause the Script to stop running. To delete them, right click on them, then select “Delete Breakpoint”. By now, you should have a basic understanding of Scripting. Let's go ahead and learn what “Services” are. The next thing we're going to be learning about are “Services”. You may have seen things like: game:GetService() This is how we actually retrieve Services. In here, you can type the name of a Service. For example, “Players”. Before that, you should create a Variable so I'm going to call this: local players = game:GetService(”Players”) This will give me the “Players” Service. Not all Services are visible in the Explorer, but the “Players” Service is right here. All Services have different kinds of uses. For example, “DataStoreService” is most commonly used to save player data. Let's take a look at the most common use of the “Players” Service. If you're a bit confused by what's happening on this line of code, don’t be worried, because we’re going to be looking at “Events” and connecting Functions later. However, it's really simple. When a player joins the game, we're going to be connecting this Function and inside here you would normally just type the name of a Function, but instead what we're doing is just putting a Function inside, and it looks something like this. This closing bracket at the “end)” is for the opening bracket at “(function” and these two brackets are where you’d put Parameters. Once again, we're going to be looking at this later. So let me show you guys how we use “PlayerAdded”. What I've done here is use “Instance.new” We already learned about what it does, and I've created a folder. What I've done here, is added a Parameter for the player that's joining the game because this will go off every time a player joins the game. It's going to run this code every time a player joins the game and it tells you which player joined the game right here. Now that we know which player joined the game, we can use that in the Function. So what I've done is created a Folder using “Instance.new”, I’ve named the folder “leaderstats”, and I've set the “Parent” property to “player”. As I said in the beginning of this video, Scripting is just changing different properties at different times. What we're doing right here is creating a new Instance, updating the “Name” property, then updating the “Parent” property. Same thing over here. We're creating a new “IntValue”. If you don't know what that is, click the plus and add an “IntValue”. The “IntValue” allows you to set it to any “Integer” / whole number. You can’t set a decimal number (because it’s not an Integer). Now, I’ve changed the name property to “Coins”, set the “Value” property to “5000”, and set the “Parent” property to “leaderstatsFolder”. When I run the game, you'll see that I have “5000 coins” on the leaderboard. So let's take a look at exactly why it did this. When I joined the game, the code went off in this Function, and what it did is it first created a folder. It created the Folder but it did not give it to my player yet. Remember, this folder is not parented to anything at this time. Then I changed its Name to “leaderstats”, and then I moved the folder into the player object that joined the game. We know which player joined the game by using the Parameter right here. Remember, this code runs every time a new player joins the game. The next thing we did after that is create a “coinsStat”. This is an “IntValue” and it wasn't parented to “leaderstats” yet. After that, we set the “Name” property to “Coins”, then we set the “Value” property to “5000”, then we set the “Parent” property to “leaderstatsFolder”. That's why the “Coins” IntValue is in here and that's why “Coins” shows up in the built-in leaderboard / playerlist. There are many different types of Services in Roblox Studio. You can find them all in the Object Browser, as we discussed earlier. For example, “AssetService” lets you get bundle details, AssetIds for certain packages, and there's also other Services. There are about 139 different Services, so it's important that you use the Object Browser to find info about the Services whenever you need them. Another cool Service is “VRService”. This Service has its own Properties, Events, and Functions. It all comes down to how well you can use the Object Browser and the Internet to learn about Services. If you want to dive into all the different kinds of Services on Roblox, check the video description for a playlist that has many of the Services you're going to be using while Scripting. Next, let's actually get to the fun part of Scripting. Let's learn “Events” and how they actually make your game work. Now let’s actually make your game work. Let's use events to make things happen when other things happen. Let's make a variable for the “RedPart”. local RedPart = game.Workspace.RedPart If you take a look in the Object Browser, you'll see that Parts have a certain Event. Remember how I told you guys not to worry about the lightning bolt symbols? These are all “Events”. Let's take a look at them. This event right here is called “Touched”, and this Event goes off whenever a Part touches another Part. We know that a Player’s Character is made out of Parts, so we can detect when a Player’s Character touches a Part. This is how “kill bricks” / “lava parts” actually work. So what I'm going to be writing is: RedPart.Touched After that, we need to connect it to a Function. Remember, a function is a block of code that we can run whenever we call it. I'm going to connect a Function to this Event so the code in the Function runs when the Event goes off. You all should be able to understand this code by now. It's a simple Function. We're calling this Function by connecting it to the “Touched” Event. What happens when the Part is touched by another Part? This Function (”PartTouched”) will run. If you click on this, you'll be able to see that there is a Parameter. This Parameter is called the “otherPart”. So not the “RedPart”, but the Part that touches the “RedPart”. We can actually take that in as a Parameter. It's called “otherPart”. Usually it's just called “hit”, though. Remember, the “Name” property is actually a “String”, so we can print “hit.Name” It's going to tell us the Name of the part that touches the RedPart. If this does not make sense, remember that the “Touched” word in “RedPart.Touched” is an event and we're connecting a Function to that Event. So the code in the Function will run when this Event goes off. This Function right here (the one named “PartTouched”) is the Function we’re connecting. And there's one Parameter that this Event gives us. When the Event goes off, it records the part that touched the RedPart and then it passes it through as a Parameter and we're able to pick that up here. If you're unsure about what Parameters you can get from an Event, just click on the Function and you'll be able to see the Parameters right here. For example, the only Parameter for the “.Touched” Event is the “otherPart”, and we usually call the other part “hit”, so I just named it “hit” here. Let's run the game and hopefully that'll clear up some confusion. The first thing we see is “Touched” and “Baseplate” because the RedPart touched the Baseplate. I'm going to walk on the RedPart, but before that, let me show you all the Character model. I have all these different parts and these all have their different Names and you'll see these Names right here. As you can see when I touch it, you can see all of these Names of different body parts from the Character touching the part. One thing that all these body parts have in common is their Parent, which is my Character. This is important to know for the next thing I'm going to show you all. Before I show you why that's important, let's actually move this Function in here. This is really simple. Just copy the Function, then paste it inside the “:Connect()” on line #8. One thing to note is that this is an “Anonymous Function” that means there will be no name, and I can’t just call it later. This Function will run whenever this Event goes off, so make sure you delete the name right here. You'll be left with the space right here, you can get rid of that. This does look a lot simpler, and if you haven't understood already, this Parameter right here is getting passed into the Function here. This means the “otherPart”, the part that touched the “RedPart” is called “hit”. Inside the Function, I can access that part at any time. As you can see, the parts that were touching the RedPart are printed here because of this Print Statement right here. We were looking at the part that touched the RedPart and printing the “Name” property. Let’s say I wanted to figure out which player actually touched the RedPart. Remember, the parts that are touching the RedPart are body parts, and one thing they all have in common is the player’s Character that they're parented to. So what I can do is write: local playerCharacter = hit.Parent Remember, we always have a Player in the “Players” Service and we have a Character in the “Workspace”. The player usually holds things like your “Backpack” “PlayerScripts” and “leaderstats”, while the Character contains any equipped Tools and Clothing. That's because we can actually see those things in the Workspace. So now that we have our “playerCharacter”, I'm going to print the player's Name property just for proof of concept: print(playerCharacter.Name) Now there's no check here to check if it's actually a player touching the part. So it's just going to print the Parent (specifically its Name property) of anything that touches the part. For example, you can see “Workspace” right here. That's because the Baseplate is inside the Workspace. If I touch the RedPart right now, it's going to print my Username, because some of the Character’s body parts are touching the RedPart. That means all the body parts go through the function and then we’re checking the “Parent” property of all the body parts. All of the body parts are parented to the Character model, and then we’re printing the Parent’s “Name” property. The “Players” Service has a Function that can tell us if a model is a Player’s Character. The Character model in the Workspace when I'm walking around is actually just a model. It has the same Name as my Username. Let’s create a Variable for the Players Service. local players = game:GetService(”Players”) Now, let’s call the Function. I'm going to make a Variable for the player. If you remember “Returning”, what this Function essentially does is it returns the Player object and it doesn't return the Character in the Workspace. That's the player's Character. It returns the Player from the “Players” Service. This helps us access things like “leaderstats”, “Backpack”, and “PlayerScripts”. But remember, this Function will return “nil” if the model isn’t actually a Player’s Character. For example, we saw the Workspace, and since the Workspace does not correspond to a player in the “Players” Service, it's going to return “nil”. To prove this concept, let's write: print(player.Name) and then try it again. As you can see, when the Baseplate touches the RedPart, it gets the Parent of the Baseplate and then it runs that through “:GetPlayerFromCharacter()” Since the Workspace isn't a Character of any Player, it's just going to return “nil”. Since we told it to print whatever it returns, it's printing “nil”. Now, if I were to step on this RedPart, it's going to print my Username. That's because when I step on it, my body parts become the “hit” parameter and then we get the “hit.Parent”, which is the Character model, and then we run the Parent through this Function, which returns the Player. The Player object that it’s returning is my player inside the “Players” Service. That's mostly all there is to Events. You can look through the Object Browser and find all these different types of Events. Some Events are standard and they're on everything, like “AncestryChanged”, “Changed”, “DescendantAdded”, and other ones are unique. For example, “Activated” fires whenever you click the left mouse button with a Tool. (There’s also an “Activated” for GuiObjects such as TextButtons) When I say “fires”, I mean running the code that the Event is connected to. For example, the Touched Event is connected to this code here. Next, let's look at the difference between “:FindFirstChild()” and “:WaitForChild()” Running this code right now prints the color “Really red”. That's because we go into the Workspace and we find the RedPart, then we print its “BrickColor” Property. However, if the “RedPart” was not there and we run the game, it's going to cause an error in the Script. As you can see, the Script has an error and the Print Statement below it did not run. To further demonstrate this, I printed “Code reached line 4!” and it didn’t print that. That's because after the first line, the code didn't run. It didn't even run line #2. That's of course, because of the error. So what do we do if we don't know if there's going to be a part there? For example, if we're looking for a Tool inside a player's Character to check if they're holding it or not, we would use “:FindFirstChild()” First, let’s change this to: game.Workspace:FindFirstChild(”RedPart”) Now, if we run the game, it's not going to throw an error. One more thing to add, is if you are using “:FindFirstChild()” let me show you all how to use the Variable. This is a simple “if statement” where if the RedPart DOES exist, we're going to print the RedPart’s “BrickColor”. However, if it does NOT exist, then we're going to write: warn(”No red part!”) Since it doesn't exist, this condition will not be met because there is no RedPart, and it's going to move on to this code here (in the “else statement”). After that, it's going to continue moving on. It says “No red part!”, but it didn't throw us an error. It said “Code reached line 4!” By the way, “warn” just makes a Print Statement but it’s orange and bolded (in Studio’s dark theme, at least). “:WaitForChild()” is a little bit different. First of all, we don't use “:WaitForChild()” like that. What we’re going to do right here is write: game.Workspace:WaitForChild(”RedPart”) If you know the Script can absolutely NOT continue without finding the RedPart, then we use “:WaitForChild()”. When using “:WaitForChild()”, the Script will pause on line #1 until it finds the “RedPart”. *Even if it takes over 100 days, the Script will stay here until the RedPart appears in the Workspace. (*Extra note by Emancyphur: By default, the Script will output “Infinite yield possible” after waiting for 5 seconds without finding the object (but it will still continue waiting). If needed, you can specify how long it should wait before giving up, like so :WaitForChild(”RedPart”, 10), with the second argument being how many seconds it waits before giving up and continuing to run the next lines of code, even if the object was never found). What I've done in a separate Script is waited 4 seconds, created a part, named it “RedPart”, and then added it to the Workspace. This means the Script will wait here for 4 seconds until “RedPart” appears in the Workspace. Then it'll continue going down in the Script. Let's run the game and see what happens. As you can see, nothing is happening and after 4 seconds it prints in the Output. The reason it printed a different color is because we didn't set the color of the “RedPart” that we spawned in. For example, if we set the part’s BrickColor to “Lime green” and run the game, after 4 seconds, it's going to print: “Lime green” and “Code reached line 4!” If you don't know what “BrickColor.new()” does, basically, whenever you’re setting a “BrickColor”, instead of writing a number or a color in a String, we write “BrickColor” (and then create a new BrickColor by writing “.new”) in a similar way to “Instance.new()”, and inside the brackets, we write a color. To test what you’ve learned so far, I'm going to give you all a little challenge, but before that, I just want to show you all something about the “Humanoid”. Remember, every player has a “player object” inside the “Players” Service, and then their Character is inside the Workspace. And we can use “Players:GetPlayerFromCharacter()” by passing in this model as an *Argument and it'll return the player object. But that's besides the point. In the Workspace, If you look inside your Character, you'll find a “Humanoid”. This Humanoid holds a lot of properties about your Character. For example, when you jump, the “Jump” property becomes true, and when you sit down, the “Sit” property becomes true. Along with that, it also holds your “JumpHeight” and your “WalkSpeed”. However, the property we want to focus on is “Health”. When Health is set to “0”, it kills the Character. Now that you know this, see if you can modify this code to kill the Character. Go ahead and try it out in Roblox Studio. Pause the video right now and I'll reveal the answer in a couple seconds. Don’t worry if you couldn’t figure it out. I'm going to show you all exactly how to do this in a Script right now. Let's say we wanted to make this “GreenPart” kill Characters when they touch it. First, we create a Variable for the “GreenPart”. We know that in the Object Browser, under “Part”, is an event called “Touched”. That means we can use that event in the Script. Let's write: GreenPart.Touched:Connect(function() end) Clicking inside of here tells us there's an “otherPart”. I remember when using “Touched”, we usually just call it “hit”. However, no matter what you name it, it's going to give us the exact same thing: The part that touched the “GreenPart”. I want to use “:GetPlayerFromCharacter()” So let’s create a Variable for the Players Service. local player = players:GetPlayerFromCharacter(hit.Parent) If you don't understand this line, feel free to go back in the video (timestamp 29:32) to learn this function again. Now let's check if there's a player. Remember, if the “otherPart” is inside of a Model, and the Model is not a Character, then “player” will just be “nil” here. Let’s write: if player then Now, inside this code block, we can assume that the player Variable actually belongs to a player inside the Players Service. What I've done here is use “:FindFirstChild()” to check if there's a Humanoid inside the Character, and then if there's a Humanoid, we're going to set its Health to 0. Obviously, since it is a player’s Character, we can already assume that there's going to be a Humanoid, but just for extra safety, we can use “:FindFirstChild()”. Let's go ahead and try this out in game. Walking over to the “GreenPart”... It does, in fact, kill me, and that's because of the code I just wrote. So remember everyone, don't worry if you weren't able to understand this. It’s a little bit complicated, but now that you know, I'm sure that you would be able to do it if you were to be asked again. The next thing we're going to be learning about in Scripting are “Loops”. Loops are incredibly useful in Scripting. This is because of all the use cases, for example, games like “Murder Mystery” are “loop games”. The game is ran over and over again inside of a game loop. Let me show you all a simple Loop that just prints something in the Output over and over again. I'm sure you can guess what this loop does. Every 1 second, it’s going to print “Hello!” in the Output. Let's go ahead and test it out. As you can see it’s printing “Hello!” every 1 second, in the Output. One thing I want to emphasize is that code will NOT run after an infinite Loop. *The Script will be stuck inside this infinite Loop forever. (*Extra note by Emancyphur: Unless you add a “break”, which immediately stops a Loop from running.) Any code before this will run, however. As you can see, it printed “Start of script!” and it continuously prints “Hello!” However, it doesn't go after the Loop. Once again, that's because the Script stops / yields at the Loop. Another type of Loop is a “while true” Loop. These Loops actually crash games and that's because the code runs an infinite amount of times very quickly. That's because there is no waiting in this Loop. It just runs the code as much as it can in as little time as possible. Normally what you do is write: task.wait(Number in seconds) and you put your “wait statement” inside the “while true do” loop. Another type of Loop is called a “For Loop”. “For Loops” are similar in the way that they run code over and over again. However, “For Loops” count numbers. Let me show you all. If you could guess, most people would probably say that this prints every number from 1 to 10. As you can see, it prints every number from 1 to 10 in the Output. That's because the Script works kind of like this: This Number right here is the starting Number (1). We start at “1”. As you can see in the Output, we started at “1”. This number right here is where it stops (10). As you can see, we stopped at “10”. This Number is the “step” (the other “1”). We count up by “1” each time. If we set the step to “2”, it's going to count up by “2”. As you can see, it counted up every number by “2”. The reason we only see odd numbers here is because we're starting from an odd number. We started at “1”, then we went to “3”, “5”, “7”, and “9”. We obviously can't go to “11” because that’s past our stop point (10), so we just stopped at “9”. One other thing to take note of is that the Script actually continued after the “For Loop”. That's because we've finished executing this code. We made it to “10” and then we moved on with the Script. Another important note to make is that we can put wait statements inside For Loops. For example I can wait 0.2 seconds between each Print Statement, and in the Output, there's a noticeable delay when it’s printing these Numbers. I think this right here is a great place to pause the video and take a screenshot. That's because this will help you remember: “Start”, “Stop”, and “Step”. There's actually another kind of “For Loop”. Let's go ahead and take a look at how it works. In the Workspace, I created a folder and I named it “FolderOfParts”. Inside this, I created a bunch of parts and they all have the same Position, Size, and Color. All the parts are exactly the same and they're inside this folder. Now let's say I wanted to do something to all of these parts at once in a Script. We can't just write: game.Workspace.FolderOfParts.Part because that is only going to affect one of the parts, and that’s probably just going to be the first one. That's why we use a “For Loop”. Now, it's important to remember that there are other use cases, too. For example, if you want to loop through every player object in the game, we would do exactly what I'm about to do, except we would do it for the Players Service instead of the “FolderOfParts”. This may look complicated at first, so just bear with me here. Hopefully this clears it up a little more. What this Loop does, is it goes through each of these parts and it runs all this code, one time for each part. To demonstrate this, let’s change the Name of each part. Let’s write: value.Name = number What this will do, is for each part, it's going to set its “Name” to the number that part is, inside the folder. Let's also use a “wait()” so we can visualize it easier. Now that I ran the game, you can actually see in the Workspace, each of these parts are being renamed to numbers. Hopefully that made sense. If it didn't make sense, feel free to join the Discord and ask any questions you have. Now I want to show you all a statement called “Break”. What it does is it “exits” / stops a Loop. It's usually used inside of an “if statement” because there's no other way to really say: “if something happens, break out of the Loop.” What I've done here, is for each of these values (for each of these parts), what we're going to do is check in the Workspace if there's a part called “EndPart” or any object called “EndPart”, and we’re going to break out of the Loop. So let's go ahead and run the game, then create a part called “EndPart”. To demonstrate it doesn't have to be a part, I’m going to use this “ClickDetector”. Let's open up this folder, then let’s name this “EndPart”. As you can see, the parts are still being named, and as soon as I write “EndPart”, it printed “Outside of loop!” If this still doesn't make sense, let me explain it again. What this line of code says is: We go through game, then Workspace, FolderOfParts (right here), and then we “:GetChildren()”, which includes all of the parts right here. Remember what “Children” are from the beginning of this video. The “number” represents the number of times we've gone through the loop. So if this is our 10th time running this code, the number would be “10”. The “value” represents the actual object we're editing. If you saw, we're editing all the parts, one by one, that's basically what's happening. The value changes each time the number goes up each time we go through this loop, what we're doing is we're checking if there's an object in the Workspace called “EndPart”. And if there is, we're breaking out of the loop using this “break statement”. Remember, when the Script finishes this Loop, it goes on to continue here and it doesn't print “Outside of loop!” until we break, as you saw previously. Now, I do want to show you all something. If we open the Workspace and go to the “FolderOfParts”, you'll see everything being renamed. However, if we were to create a Model (or anything else) and rename it to “EndPart”, it's not going to end this code. As you can see, the parts are still being renamed and that's because I made the change on the client side. If I were to switch over to the server side, and then create something called “EndPart”, as you can see, it printed “Outside of loop!” because it broke out of the loop. However, switching back to the client, let's go over why this happened. If I make any changes on the client side, let’s pretend I’m an exploiter and I get access to the Explorer with cheats, what I could do is actually change anything* in the Explorer. That's why when exploiters go into a game, they're able to delete walls and all that, but you won't see that on your screen. As you can see, I'm playtesting the game on two different accounts. This account on the right side of the screen is called “Player2”, and the other account (on the left side of the screen) is called “Player1”. To demonstrate this, I'm going to go to “Player1”, I’m going to pretend that “Player1” is the exploiter. I'm going to get access to the Explorer, I'm going to open up the Workspace, and I'm going to delete the “BluePart”. As you can see, it's gone on my screen (Player1), however, it’s not gone on Player2’s screen. In the Explorer, the “BluePart” is still there. If you're wondering why this happened, it all kind of goes back to “LocalScripts”. If you remember in the beginning, I told you all to make sure you're inserting normal “Scripts” and not “LocalScripts” or “ModuleScripts”, and that's because “LocalScripts” run for the player. That means the LocalScript is run for each player, individually. Each of those players can have anything that LocalScript and other players in the game will not see those changes. However, if I were to switch over to the server side and delete the “GreenPart”, (I'm on the server now) and when I delete the “GreenPart”, you can see the “GreenPart” is gone for both players. This happens because that is on the server side, that's a “Server Script”, and it runs for the entire Server. That was a really basic explanation and if you don't understand, I highly recommend the video I have linked in the description, it'll teach you everything you need to know. The final thing I want to go over with you all is right here. “Size”, “Position” and “Orientation”. Something to understand about these numbers is that they're not “normal numbers” like “Transparency” or “Reflectance”. As you can see in the Script, if I were to try to change the “Position” property like this, it's not going to work. It thinks we’re assigning three different values to one Variable. Just like “Instance.new()” and “BrickColor.new()”, there’s something called: “Vector3.new()” A “Vector3” is basically the group of 3 numbers that we're looking at here. To create a Vector3, we write: Vector3.new() and then we can put our 3 numbers. As you can see, it says: “number x, number y, and number z”. If you go to the “View” tab and you turn on the “View Selector”, you can see the “X, Y, and Z”. Increasing the “X” value sends parts this direction, increasing the “Z” value sends parts that direction, and increasing the “Y” value sends parts upward. If you’ve played “Minecraft” a lot with coordinates on, you’re probably a lot more knowledgeable about this system, and it'll be a lot easier for you. Similarly to the “Position”, I can also set the “Size” and “Orientation”. Just like that, I set the “Size” and “Position” to a Vector3 value. Let's go ahead and run the game to see what it looks like. There's a “BluePart” right there, and in the Properties window we can see the “Size” and the “Position” we set. Because of how Roblox rounds numbers (*also because of floating point errors), it's not exactly “3”, but don't worry, it's pretty much “3”. Pay attention to the “BluePart”. Let's see if we can notice a difference between “2.999” and “3”. It moved about one or two pixels on my screen, however, that will likely never be noticeable and it probably will never affect your game. Let's say I just want to change the “X” axis and the “Z” axis of the “Size” property, and I want to keep the “Y” axis the same. But what if I don't know what the “Y” axis is going to be at this time in the game? One simple thing you could do is write: *“BluePart.Size.X” (*correction in a few seconds) Let me go ahead and show you all this. As you can see, I wrote: “bluepart.Size.Y” The other two axes (the X and the Z) will change to “10”, while the “Y” axis will remain the same (whatever it is now). Let’s go ahead and run the game to take a look. As you can see, the “Y” axis remained the same, and the “X” and “Z” axes were set to “10”. Now that you’re done with this video (it could even be your second or third time), you might have no motivation. This is actually really common, you shouldn’t worry about that. Click this video on the screen and I will motivate you all to keep going and you'll be able to create great Roblox games for this platform. You now understand the basics of Scripting and you can call yourself an “Intermediate Scripter”. However, it’s going to take a lot of practice to become an “Advanced Scripter”. I recommend doing commissions to build / gain experience. Thank you so much for watching this video! If you forgot to, make sure to subscribe! I’ll see you all in the next video. Peace!", "scraped_at": "2026-01-08T15:05:05.020841", "error": ""}