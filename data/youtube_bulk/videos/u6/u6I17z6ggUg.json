{"id": "u6I17z6ggUg", "title": "Raycasting (Guns, Visualizers, Shapecasts) - Roblox Advanced Scripting #37 (2025)", "channel": "BrawlDev", "views": 67074, "duration": "46:02", "url": "https://www.youtube.com/watch?v=u6I17z6ggUg", "query": "roblox scripting tutorial", "transcript": "This is raycasting. A simple to understand idea yet very difficult concept to implement on Roblox. And it has many practical use cases as seen in very popular Roblox games. Think of games like blocks fruits where they have projectile based abilities that use ray casting or games like bedwars to determine what blocks can be destroyed by the players when they click on them. Those only scratched the surface of what you can do with ray casting, but in general, it's one of the most popular Roblox scripting concepts ever. My name is Baldev and in this advanced scripting tutorial episode, we'll be covering what ray casting is and how we can implement this inside of our own Roblox games. And by the end of this video, my goal is to equip you with the knowledge to understand ray casting on a fundamental level and can script ray casting for your own systems. But before we do, let's think about this for a minute. The first thing we want to ask ourselves is what the heck is raycasting and how can we use raycasting inside of our scripts to make really cool systems. So I have this little visual example here and to give you a fundamental definition of what ray casting is, it's the process of sending out an invisible line from a starting point in a specific direction with a defined length. So to help you understand what I'm talking about here, we have this red line here that's going to represent our ray. And we have this blue part here that represents our starting point of this line. And so if we were to take this line and we start it over here, then what we're going to do is we're going to use ray casting to essentially shoot a ray in a specific direction with a defined length. and it's going to try and detect if there's an object that intersects with that line. So, in other words, when we shoot this ray, we cast the ray to the world, hence the name ray casting, and it's just going to shoot a line like this, and it's going to try and detect an object that's in the way of it. And if it does detect an object, then we're going to get information about that object in specific to then do stuff with our scripts. So, it seems pretty cool and all, but how does this actually help us as Roblox developers? Well, let's say for instance, we have a system like uh a turret where if a player walks in front of the turret, then we want to get information about whether this is a player that's standing in front of the turret. And if it is a player, then we want to start firing the turret in this direction. Or let's say we have a gun system where if we shoot in a specific direction, then we want to use ray casting to fire a bullet from the gun to where the player clicked on their mouse. Let's say another use case is if we want to have a placement system where we want to get the player's mouse and we want to locate it with respect to the game's world to be able to place down items inside of the game. That also uses ray casting. There's even things like weapon hit detection. So, if you have like a sword and you want to be able to detect if a player is being hit by your sword's hitbox, then that's another practical use case of raycasting. And it's, as I mentioned before, the list just goes on with ray casting. It's a very widely used concept in Roblox scripting, but it can be challenging to those who have never used raycasting before. And my goal for this video is to teach you the fundamentals of raycasting and how you can use raycasting in your scripts to make really cool systems like this. So with that being said, let's go ahead and go straight into implementing ray casting. Now that we understand it, let's implement ray casting inside Roblox Studio. Now it's as I said earlier in this episode, in order to perform ray casting, we need two pieces of information. One is the starting point, also known as the origin, and the other is the direction that we want to take from that starting point. And an easy way that we can do this is by using a part as the starting point. And then we specify our own direction based off of that starting point. So what we're going to do is go into model and we're going to insert a part. Now with this part, I'm going to scale down just a little bit. I'm going to change the brick color to something different. I'm going to set anchored to true. And I'm also going to rename this part to origin part just like this. Now what we're going to do is go inside of server script service, hit the plus sign, and we're going to insert a script. Now from here we're going to first make reference to our origin part by saying local origin part equals workspace.org part just like this. Now we need to specify a direction. Now this direction can be any vector 3 value that we pick. But let's say from the origin point we want the ray to be 100 studs going this way. So if we were to specify the direction by saying local direction equals vector 3. Uh then what we're going to do is put 100 for the X and then zero for the Y and then zero for the Z. So when we combine our origin part with its direction, the ray is going to look something like this where this is the starting point and then it goes 100 studs this way. So this is what the ray is going to look like when we cast it into the world. Okay. So now that we have our pieces of information, how do we actually cast the ray into the world? Well, we can do this using the workspaces raycast method and we're going to be doing that under a loop by either using a while loop or by using run service. But in this case, we're going to use run service. So at the top here, we're going to make reference to run service by saying local run service equals game get service run service just like this. Now down here we're going to say run service heartbeat colon connect function open close parenthesis enter. Now we're going to use that raycast method that I mentioned before. So, what we're going to do is say workspace colon raycast open and close parenthesis. And this takes in three pieces of information, but right now we're going to be focused on the first two, which is the origin. So, we're going to say origin part.position. And then we're going to throw in the direction as well. So, this casts our array into the world. And this is going to return what's called a raycast result that gives us information about the object that this ray has hit. So we're going to throw this inside of a uh variable by saying local ray result equals and then the workspace raycast method here. So from here we're going to say if ray result then this is basically going to tell us that there was an object that actually hit the ray. So, we're going to say something like something has hit the array. Uh, otherwise, we're just going to say nothing has hit the array or something like that just to tell us information about whether there is an object that was actually in the way of the ray or not. Okay. So, in order for us to tell whether this is actually working, let's insert another part here. I'm just going to make this like a big wall just like this. And what we're going to do is go to test and hit run. And basically inside the output it's going to say that nothing has hit the ray multiple times. So right now the ray looks something like this. And if we were to move this object in the way of the ray then as you can see in the output it says something has hit the ray. And if we move the wall away again then it's going to say nothing has hit the ray. So this is the basic idea behind ray casting. It's to shoot array into the world and it's to give us information about objects that intersect that array. That's the whole idea behind it. Now, you might be wondering what information does this raycast actually return. Well, if we go back into our script and let's say that ray result was successful and we say ray result dot, we can see that there's five pieces of information that ray result does provide to us. The first one is the instance which basically tells us what was the instance that hit the ray. The second one is the exact position as to where the ray and the part hit each other. Uh the third thing is the material of the object that the ray hit. And then we have a normal vector and we also have a distance which tells us how far apart was the ray origin and the point at which both the ray and the object hit. So depending on what you're creating, these pieces of information can be really helpful in terms of what you want to accomplish with ray casting. Okay. So before we move on, I want to help you visualize these rays that we're creating by using a function that basically shows us what these rays look like so that we're not working with invisible rays throughout this entire episode. And so basically what I did was I created this function here called visualize ray that takes in two parameters. One is the origin and the other is the direction. So if we open this up, basically what's happening here is we're creating a new part. We're setting some properties and we're setting the parent of this to workspace and we're using debris to automatically get rid of this part after 0.5 seconds. Now what we need to do to complete this function is by defining some variables and by changing the size and the C frame of this part to accurately reflect on what the rays will look like and where it's placed. So we need two pieces of information which I'm going to explain what these are in just a little bit. But we need to define the length and the midpoint. So what we're going to do is say local length equals direction domagnitude just like this. And then we're going to define the midpoint by saying local midpoint equals origin plus direction* 0.5. So length is what's used to tell us how big we want this laser to be. And then midpoint is what's going to tell us where we want to position this ray that we create. Now the reason we want midpoint rather than let's say starting this laser at where the origin is is let's say we had a laser that looked like this. So we positioned this laser to be where the origin is. But if we were to change the size of this to make it look like this, then obviously this isn't where we want the laser to be. Instead, we want the laser to be like this instead because this reflects our ray more accurately than what I was showing you just a second ago. And in order for us to get this accurate position, we need to take the origin and the direction. So this is the origin and this is the direction. And we want to get half of that which is in the center here. This is the midpoint and this is the the the exact position that we want when we're trying to cast this ray into the world and by visually showing this as well. So that's what I'm trying to show with both the length and the midpoint. And now we can change the size in the C frame with these pieces of information. So what we're going to do is say new part do size equals vector 3 new. We can set X and Y to be a really small number like 0.1 and 0.1. And then for Z, we're just simply going to throw in the length just like this. And now what we're going to do is say new part. Cframe equals Cframe new. And then inside of here, we're going to start it at the midpoint. So it's going to start right here in the center. And for the look vector, we're going to say origin plus direction just like this. And this is all that we need to do for our visualize ray function. So now what we can do down here is inside of our heartbeat loop. As soon as we get the ray result, we're going to say visualize ray and then we're going to pass in the origin part.position and then we're going to throw in the direction just like this. And this is our visualize ray function that's going to be helpful for us. So if we go into the game, I'm just going to delete this origin part. And if we hit run, then what we should see is now we have a visual array that we can look at to really see what is actually happening inside the workspace. So, if I were to move this part in front of the ray, then what it's going to do is it's going to say that something has hit the ray. And if we lift it back out, then it's going to say nothing has hit the ray. And so, this is what we're going to be using for the rest of this episode to really help us visualize what these lasers are going to look like. Okay. So, right now, we have a one-part raycast system where we have a part that acts as the origin point and then we have a direction that tells us how far do we want this ray to shoot out. So, it looks something like this currently. And we can move this starting point around to adjust where the ray is inside the world. But what if we wanted to create a two-part system where we have a starting point that's going to be a part and then we have an ending point or a goal that's also going to act as a part. So it's a two-way system where if we change the goal or the starting point, then it's going to affect how the raycast is displayed in the world. We can do that really quickly if we hit stop. And what I'm going to do is duplicate this origin part, move it over here. Uh I'm going to rename this to goal part. And I'm going to change the brick color this to something like yellow. So if we go inside of our script, what we're going to do is first make reference to the goal part by saying local goalpart equals workspace.galpart. And then what we're going to do here is we need to specify the direction based off of the goal parts position and the origin parts position. So, I'm going to comment out this direction definition up here, and I'm going to move it down here by saying local direction equals goalpart.position minus origin part.position. And then we're going to use this new direction to define our ray inside of the world. So if we now hit run, then what's going to happen is we're going to use ray casting to shoot array from the origin point and to the destination as well. And if we were to change either of these parts, then as you can see, the raycast is being updated to reflect on these new positional changes either on the goal or at the origin. So, this is pretty cool if you know the destination plus the origin so that you can create raycasts into the world that reflect on both of these parts just like this. Now, you might notice something. It says down here in the output that something has hit the ray and it keeps displaying this for some reason. There isn't anything blocking it. So, what's the problem here? Well, the problem here lies in how we specified that any object whatsoever, it doesn't matter what object it is, it is going to detect anything that's in the way of this ray. And what is this part? Well, the part that this ray is intersecting is this goal part right here. But what if we don't want this goal part to be part of the raycast detection? Well, this is a perfect transition into what we're going to be talking about next, which is called raycast parameters. So, raycasting has this cool feature that allows us to choose which specific instances can either be included or not be included in the list of instances that can be intersected with the rays that we shoot into the world. So, how this can be useful is with the example I just explained earlier and how we have a starting point, which is this part right here. So, we shoot the ray starting from here and then it goes into the goal part. But on the output, it's been saying that something has hit the ray even though nothing is actually in between these two points. And that's because it's detecting this goal part right here, which we don't want to include in the list. So, in order to handle situations like this, we're going to create what are called raycast parameters and add this goal part to the list of instances that are not allowed to be intersected with the ray. So let's go to our script so that we can make this change. And what we're going to do is create raycast parameters by saying local raycast params equals raycast params new open and close parenthesis. And now inside of here we're going to say raycast params dot filter descendant instances equals open and closed curly braces. And this is the table of all the instances that we don't want to include in the list or instances that we do want to include. So in this case, we're going to say goalpart here as the only instance in the list. And then we're going to say raycast params dot filter type equals enum dot raycast filter type dot. And then we have two options with either excluding or including whatever is inside of this list. But for this example, we're going to say exclude because we don't want to include this goal part as one of the instances that can be detected by this array. And finally, what we're going to do is we're going to throw in a third argument inside of our raycast method. And we're just simply going to pass in the raycast params just like that. So now if we go into the game and hit run, what we should see in the output is now nothing is hitting the ray, even though it technically is hitting this goal part, but we chose to ignore this goal part with this ray that's being fired. And if we move the wall over to here, then it's going to say that something has hit the ray, just like so. And if I lift it back out, then it's going to say that nothing is hitting the ray again. So raycast parameters are very useful if we don't want specific instances to be intersected with the rays or if we want only a specific number of instances to be intersected with the rays and we just ignore everything else. Okay, so with what we know, let's create a gun system using ray casting. And I want you to follow exactly what I do as we create the system. And the first thing we need to do is create the gun itself. So what we're going to do is go to model and we're going to hit part. Now, with this part, I'm going to scale it down just like this. Scale it up like this. And I'm going to rename this part to handle. And I'm going to go down here and turn off can collide. Then I'm going to hit the plus sign inside of workspace, insert a tool. I'm going to rename this tool to gun. And I'm going to put the handle inside of this gun, just like this. Next thing I'm going to do is duplicate the handle, scale it down, and move it to the right like this. And I'm going to rename this to part. And then I'm going to duplicate it one more time, move it over here, and call this the point, which is going to be where our bullets are going to be fired from. So to indicate this, I'm just going to change the brick color to, let's say, black. And now we have our gun. But we need to attach all these parts together so that they don't fly off when we u actually use it in the game. So we're going to use weld constraints by hitting the plus sign inside a part, inserting a weld constraint. We're going to set part zero to the part and then part one to the handle. And then I'm going to copy this weld constraint, put it inside a point, and I'm going to change part zero to be the point instead. And now everything should be connected together. But I want you to be careful because depending on how you design this, when you hold the gun, it's probably not going to be oriented correctly. And I'm going to show you a neat trick that you can use to check to see if you're facing the model correctly based on how you're designing it. So, with this handle, what we're going to do is we're going to right click on this handle, and there should be this option called show orientation indicator. And there's this little arrow here that shows you where the front-facing side of the handle is. And so, now all we need to do is just move these parts over here so that we can orient them correctly, just like this. So, I'm just going to right click on this and then hide orientation indicator. And if we now move the gun to starter pack and if we hit test and hit play, then what we should see is when we use our gun, then it should be oriented correctly. And now we have a gun for the player to use. So that's how you create the gun. And now we need to create the functionality of the gun. So we need three things with this gun. And before I do, I'm just going to take the part and the point and put it inside the handle just to make it more organized. So we need three things. We're going to hit the plus sign inside of gun. We're going to insert a script. We're going to insert a local script. And we're going to insert a remote event. So, with all of these three things, what we need to do essentially is make it so that when the player clicks their mouse on a specific direction, then we want to send that information to the server so that we can create a ray that will shoot out from the point of the gun to the direction of where the mouse is. And that's the whole idea behind this gun. uh while we use raycasting. So I'm going to rename this remote event to fire gun. And inside of our local script, we're going to make reference to the tool by saying local tool equals script.parent. Then we're going to say local fire gun equals tool colon waitfor gun just like this. And what I'm also going to do is say local player equals game.players.local player. And then we're going to get the player's mouse. So, we're going to say local mouse equals player colon get mouse open and close parenthesis just like this. And now what we're going to do is say tool.activated col connect function open close parenthesis enter. We're simply just going to say fire gun colon fire server open close parenthesis. And there's two pieces of information that we need. So we need the origin point and we also need the direction which we specified before with raycasting. And basically what we need is the point part. So we're going to say local point part equals tool colon wait for child handle colon wait for child point just like this. So we're going to say point part.position. This is going to be our origin. And then we're going to say mouse.h hit.position which is basically the position of where the player fired their mouse. So now we're done with the local script. So, if we go into our normal script, I'm just going to copy the tool reference and just put it inside of here. What we're also going to do is make reference to the fire gun remote event by saying local fire gun equals tool. Fire gun just like this. Then we're going to say fire gun onserver event connect function open close parenthesis. So, there's three pieces of information here. There's the player, there's the origin, and then there's the mouse position. So with these three pieces of information we can now start creating raycasts on the server side. So the first thing that we need to do is calculate the direction which is basically let's imagine that this is the origin point like this is the point part and we want to make it so that we get the direction from where the mouse position was versus where the origin point was which is always going to be the point part. So if we were to let's say calculate it, it would look something like this. This is the result that we're trying to get. And the way we can do this is we just simply uh subtract the mouse position with the origin position, get a unit vector of it so that it looks something like this, and then multiply it by some sort of scaler, which shows us how far we can shoot the gun, which let's say in this case is 50 studs. It's going to look something like that. So we want to be able to calculate that inside of our script. So if we go back to our script, we can say local direction equals open close parenthesis mouse position minus origin dot unit times and then we can say however many studs we want. We can say 50. Now that I think about it, we can actually just create a uh variable here by saying local distance multiplier just like this. And then we can say something like 50 just so that we can make it adjustable later if we want to. So, now that we have that, we can go to our original script that we used earlier in this tutorial guide and we can just copy the same raycast parameters here because when we're going to be firing our gun, there are certain things that we don't want to intersect with the ray. So, we're going to go to our original script, copy this, and then paste it inside of here. Now, for the filter instances, what we can do is create a variable here called local excluded parts equals open and close parenthesis. And then we can just replace that with this. And now what we're going to do is we're going to use the raycast method by saying local ray result equals workspace colon raycast. And then we're going to throw in the origin the direction and then the raycast params just like that. And we're going to check if the result was successful. So we're going to say if ray result then we're going to say we have found something. So, result has been found. And then we're just going to print the ray result for testing reasons. And then what we're going to do is we're going to go back to our original script and we're literally going to copy the exact same visualize ray function and we're just going to paste it inside of here. Just like this. Except one thing we can do is probably change the color of this to let's say orange. And what we're going to do here is we're going to say visualize ray origin direction. Just like that. So what do we want this ray to actually do? Well, we can do a couple things. Uh, one thing is we can change the color of the instance that the bullet has hit to a different color. So what we can do is say ray results do instance.color equals color3.RGB. And then we can change this to orange. And if this ray was not successful, then what we're going to do is we're just simply going to say result not found. And then we can do the same thing with the visualize ray function. We're just going to put that here as well. Okay. So now if we go into the game, hit test, and hit play, then what we should see with this gun is if we were to fire it at a certain direction, then it's going to shoot a ray from the origin point, and then it's going to fire off in the direction of the player's mouse. And it's going to tell us if a result has been found or if a result has not been found. So if we were to shoot this wall, then it did find an instance and it changed the color of that instance to the color that we specified inside of the script. And we can do this with basically any instance that this has detected. And so that is uh something that we can do with this gun. But let's add another functionality. Let's make it so that if this gun detects a player, then we want that player to take damage. And we can do that inside of here by first locating the character. So we're going to say local character equals array result.instance colon find first ancestor of class open and close parentheses model. And the reason we say it like this is because a player's character is a model. And if we find the first ancestor of a specific instance, which is likely going to be the player's body part, like its arm or its torso or anything like that, then we're going to see if this is an actual character based off of that information. So then if we do find the character then we're going to try to find the humanoid. So we're going to say local humanoid equals character find first child of class and then we're going to say humanoid. So if the humanoid does exist then we're just simply going to say humanoid colon take damage and then we're going to specify like a damage amount like five or something. We can even set that here as well. So local damage equals five. And then we can just replace that with this damage. And I meant to say humanoid here. Okay. So now we can test this even further. If we go to avatar and we click on rig builder, we could just select any rig. I'm just going to say block avatar. And if we now go into test and hit play, then we can test out this gun by firing it at the NPC. And as you can see, it's taking five bits of damage every single time. And that's the result that we wanted to achieve from this. Now, this is a simplified way of creating a gun system using ray casting. But I hope you've been able to learn something from using ray casting to create this gun system that we just created. Okay, so one thing I forgot to do was add to our excluded parts table. Now you might be wondering what should we add to the excluded parts table? Well, there's two important things. So what we're going to do is say table.insert and then for excluded parts, we're going to include the player.c character. And the reason we want to do this is because we don't want to make sure that we hurt ourselves when we fire the ray. And also another thing is over here in our visualize array function, we want to make sure that we add the ray itself into the excluded parts because we don't want the part to be able to interact with each other when we shoot multiple rays at the same time. So we're just going to copy the same uh thing here and paste inside of here, but instead we're just going to add new part instead to our visualize rate function. So, I wanted to clear that up to make this gun system even better that actually uses the raycast parameters. Hey, post edit broad here. So, it turns out there's actually a few mistakes that I made with the raycasting gun script that we just created. And I just wanted to quickly address what these problems are and how we can create a fixed version for this because the script that we have right now technically works, but there are a few issues with it that can make this problematic. And so, I just want to quickly address them. So if we go inside of our scripts, there are two problems here. Uh one is we're using excluded parts as a global table which can actually cause memory leaks based on the way that we've implemented this. And another problem is if we scroll down here, we can see that raycast is being fired before the visualize ray method. Now you might be thinking why is this a problem? Well, if we go inside of the visualize array method over here, uh we're using table.insert insert to insert this new array that we shoot and put it inside of the excluded parts table. Now, the reason we do this is because we want to add all of these rays as filters for raycast parameters so that when we fire the bullets, the other visualized bullets are not going to be included with the ray casting, which is the whole point behind this. But if you still don't see the problem, basically when we fire raycast, we want to take into consideration all the excluded parts that are in here. But if we're adding these new parts to excluded parts after the raycast has already been fired, then there's no point of doing it because the raycast method has already been fired. So we actually need to fire visualize ray before the raycast method over here. So those are some issues that we need to change. And one thing that I want to mention with the whole memory leakage thing is when we use debris to get rid of these new parts, the references to these parts inside of excluded parts are still inside the table, which is why it can accumulate over time and create a memory leakage. So if I were to show you what I'm talking about, I'm just going to write a print statement and I'm going to print the number of items that are inside of excluded parts. So if I fire with my gun, then as you can see in the output, the number that's being displayed is the number of entries that are inside of excluded parts. And as you can see, it's not going away because the rays disappear, but the references to those rays inside of excluded parts are still inside the table. And if we keep firing this, then this is just going to accumulate more and more over time, which is not good. Which is why we need to fix this as one of the problems. And I hope that this part is making sense so far. Okay, so I created a fixed version of the gun ray casting script. Um, so if we go inside of here, then uh I I basically commented out all the parts that we don't need anymore. So this global reference to excluded parts is no longer here because we moved it down here every single time the player fires the gun. So we create a new excluded parts table every single time. And another thing that I changed was this visualize array function is now being fired before the raycast uh method. So if we go inside of visualize array, the things that I've changed here are a few things. So instead of setting the parent of the bullet inside of workspace, we're instead putting it inside of what's called a visualization folder. So this is a little folder that I created called bullet visuals and it's stored inside of the workspace. So, it's basically this bullet visuals folder right here. So, if I were to fire my gun, then all the bullets are being stored inside of this one folder. And the reason it's like this is because this makes it a lot easier for us to keep track of all the bullets that are going to be included in the raycast parameters so that we don't include them when we're firing the bullets uh inside the game. So, we also got rid of the debris method and instead what we're going to do is simply return the new part and and have it be a variable here called visual part so that we can use it inside of this part of the script. So, with excluded parts, we want to include the player's character and we want to also include everything that's inside the visualization folder with all the bullets. So, another thing is I also got rid of all the visualize array methods over here. And I also completely got rid of this else uh branch in this if statement right here because we don't really need it. And at the very end here, I added the game debris add item method and I just got rid of the visual part after 0.5 seconds. So, this is basically how we create a more robust raycast gun script that not only prevents memory leaks from happening because we're creating an excluded parts table every single time the player fires the gun instead of having it be global, but also this is a more appropriate way of using raycast parameters because now this raycast is actually taking into consideration the new bullet visual that has been created inside the game before we fire the raycast method. So, I just wanted to quickly address this because if I left the current script as is, then you probably would have been misusing the raycast methods inside of this video and I did not want that. So, I just wanted to quickly address it. And if you still are watching up until this point, then I really appreciate it a lot. I do put in a lot of time into the scripting tutorials, and there's not that much left on this episode. So, I want you to keep in mind as you follow through the rest of this video is that I'm still going to be misusing the raycast parameters. So, I just want you to keep an open mind as you follow through the rest of this episode. That is all for me. Thank you so much. Now, you might be asking yourself, is it possible to change the shape or the size of these rays? Because theoretically, ray casting is when you shoot a very tiny thin invisible ray uh inside the world. But if we wanted to utilize the functionality of ray casting, but instead using different shapes and different sizes, then it actually is possible. We can use things like block casting, shape casting, and sphere casting that can make bullets that look something like this. So we can use things like cylinders with different sizes. And we can even use things like blocks to achieve the same effect, but instead have like a bigger volume. So that's the definition of these shape casts and block casts and things like that. It's basically ray casting, but if it had volume. And so I think this is something really important to understand when you're utilizing this inside of your Roblox games. And we're just simply going to take our existing gun script and we're just going to modify it to use these casts instead of ray casting. So let's go ahead and go do that right now. Okay. So, we're going to modify our current gun system to use sphere casting to increase the size of our bullets. And basically what we're going to do is we're going to go to our script and inside of our remote event, we're just going to change two things. The first thing is instead of firing raycast, we're going to fire sphere cast instead. And this takes in four parameters instead of three. So we still have the origin, the direction, and the raycast parameters, but as part of the second parameter, this is taking what's called a radius, which determines the radius of the spherical shape in studs. So we can set this to be a number like two. But we can also just create a variable up here by saying local bullet uh radius equals 2. And then we can just replace this two with the variable we just created. Next thing we're going to change is instead of visualize ray, we're going to create our own function for visualizing the shape because we're not visualizing array anymore. We're visualizing a shape. So we're going to create a new function up here by saying local function visualize shape and then it's going to take in the origin, the direction, but this is also going to take the ray result as well. And this is what we're going to be calling instead. So, we're going to say visualize shape origin direction and then the ray results just like that. And I'm also going to copy that and paste it down here as well. Okay. So, here's how this is going to work. We're going to create a visual bullet inside of Studio and we're going to clone that bullet and shape it so that it's going to match where the player is going to be firing. And we're also going to adjust the size of it as well. So, what we're going to do is go to model, hit part, and we're going to create a cylinder, and we're going to rename this to bullet, and then we're going to change the brick color of this to, let's say, orange. And we're going to change the material of this to, let's say, neon. I'm going to set can collide off, and I'm going to turn on anchored, just like this. Okay. So now that we have this bullet, I'm going to throw this inside of server storage. And we're going to make reference to this bullet inside of our script by saying local bullet equals game.server storage dot bullet. Just like that. So now what we're going to do inside of visualize shape is we're just simply going to clone the bullet. So we're going to say local new bullet equals bullet colon clone. And then we're going to set the parent of this new bullet. So new bullet.parent equals workspace. And then we're going to use table.insertexcluded parts and then new bullet just so that the bullets are not going to be interacting with each other. And then we're going to say game. debris colon add item new bullet. And then we're going to get rid of it after 0.5 seconds. Just like this. Okay. So what's left to do here is we need to make a couple calculations so that we can be able to change the size and the C frame of this bullet accurately. Okay. So we need to calculate a few things before we continue. So the first thing is the position of the end result or the position of the goal if that makes sense. So basically what I'm trying to say is that we either hit something with the ray that we shot and we're just going to get the position of that or if we don't hit anything then we're just simply going to get the origin plus direction. That's going to give us the information about the position. Another thing we need to calculate is with that position and with the origin point, we want to be able to get the distance between them as well because that's going to be useful for us to know the size of the bullet. And we also want to get the midpoint so that we know where to position the bullet when we shoot it out into the world. So, if we go inside of our script, uh we're going to calculate these three things on top of here. So we're first going to say local position equals and this can either be one of two values. So we're going to say if ray result then so if uh if we actually did get a result from shooting the ray then we're just simply going to say ray results.position. Otherwise we're just going to calculate the origin plus the direction just like this. Next thing we're going to do is calculate the distance. So we're going to say local distance equals open and close parenthesis. We're going to take the position we just calculated. We're going to subtract that from the origin, so where the the gun was shot from. And then we're going to say dot magnitude because we just want the distance. Like we want a fixed number that's going to be telling us the distance. And then the midpoint, which is literally the exact same calculation as we did in visualize ray. So I'm just going to copy and paste that into here. Okay. So now that we have this, let's change the size and frame of this. So with this bullet, this bullet is a cylinder. So we need to figure out a way to make this cylinder work with its size and also its C frame. And I'm going to show you what that looks like here. So we're going to say new bullet do size equals vector 3. And inside of here, we want the X to be the distance. So if we were to fire from the origin over to that wall over there, then the X is just going to be the distance. So for the Y and Z, these two are going to be the same numbers because it's going to be a perfect symmetrical sphere that looks like this. And if you have taken geometry, basically a radius is like half of a circle if you were to determine the distance from the midpoint to one of the outer edges of the circle. So if we want a full circle, we want the diameter, which in this case that's what it's called, which is basically the bullet radius* 2. And for the Z, it's going to be the exact same thing here as well. So this is how we calculate the size for the new bullet. And now what we're going to do is change the C frame of it. So we're going to say new bullet.cframe equals CF frame.look at or you can use Cframe new. It's up to you. We're going to start this at the midpoint. So, this is the location of where this new bolt's going to be. And then we want it to look at the position. So, we want to make it look at the result of the array. Or if it didn't find a result, then it's just going to get the origin plus direction, and that's where it's going to be facing. Okay. But here's the problem, though. So, right now, if we go inside the game, hit test, and hit play. And if we were to try and fire this right now. So what this is going to do is as you can see the bullet is not oriented correctly. But you can see that the size of our bullet is a lot bigger now because we're using sphere casting instead of ray casting. But we just simply want to orient this in a way so that we can actually make the bullet fire from the point to the direction that it's trying to hit. And what we can do is just simply change the orientation of it. So if we go inside of our script, we're just going to multiply this by Cframe. And this takes in three parameters which are all in radians. So we want to change the yaxis specifically. So the x is going to be zero. And then the y is going to be the thing that we're going to change. And then z is just going to be zero as well. So for the y, because this takes in radians and not degrees, we're going to say math.rad open close parenthesis. And we just want to flip this 90Â°. And that is all that we need to do for this part. So now we're basically done. If we hit play, then what we should see is if we take our gun and we shoot it in a specific direction, then you can see that the bullet is now a lot bigger and we have more range with the bullet. We have a much bigger hitbox because we're using sphere casts rather than ray casting. And I think this is a really useful way of using sphere casts. But of course, there's many practical use cases that you can use with sphere casting and ray casting as a whole. And I hope that the takeaway from this video is you learned a lot about how ray casting works and how to incorporate ray casting inside of your scripts. And this is definitely one of the most fun episodes that I've been able to work on on the channel. And I apologize that it took me a really long time to actually get to this episode. I really wanted to save this episode for one of the last ones just because I think it's really cool just to learn this stuff. It's as I said in the beginning of this episode, raycasting has a wide range of practical use cases that I will not be able to cover inside of one single tutorial episode. So, my hope for this video is that since you've watched all the way through till the end of this really long video, I know that you're definitely dedicated to learning about raycasting and being able to use what you learned from this video and incorporate them inside your scripts or your systems that you're going to be creating for the future. And I can say with confidence that you can definitely use what you learned from this video and incorporate inside your scripts. It just takes a little bit of practice and a little bit of trial and error, but I think you definitely got this. There were a couple things that I left out from this tutorial, otherwise it would have just been too long. Like debunking my turret system that I showed you in the beginning of this episode that is more on the advanced side. And I decided that I'm going to make that a individual video that's going to be over on my Patreon page. So, if you want to support the work that I do and you love the content that I put out, then I will leave a link to my Patreon page in the description if you want to get access to my scripts and also some occasional bonus content that I might put out over there as well. I would also like to give a shout out to my Patreon members for their continued support. Their support has really been helping me continue making the videos that I've been putting out, and I can't appreciate them more than enough. Please share this video with anyone that you think might be interested in learning about raycasting just to get the word around and to help boost this video into the algorithm by also doing things like leaving a like on this video and leaving a comment as well. You can literally comment about anything. Just anything that can help boost this video into the YouTube algorithm. That would be really appreciative. Like I do spend a lot of hours researching each and every one of these videos to try to make them as high quality as they can be for you guys to to really learn these scripting concepts. and I'm really appreciative of you for sticking around this long in the advanced scripting tutorial guide and what we've been able to accomplish throughout this entire journey and I'm really thankful for that. So that is going to be it for this episode on raycasting. I hope you enjoyed this episode and you learned a lot from it and I will see you in the next one. Take", "scraped_at": "2026-01-08T15:05:25.490833", "error": ""}